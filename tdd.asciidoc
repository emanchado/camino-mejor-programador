Desarrollo dirigido por pruebas
===============================
Joaquín Caraballo

El desarrollo dirigido por pruebas (o TDD por sus siglas en inglés) consiste en escribir la prueba que demuestra una característica del software antes de la característica en sí; de forma incremental, se va acrecentando una batería de pruebas con el código para explotación, al ritmo de

__________________________
rojo - verde - refactoriza
__________________________

Donde el paso rojo es la escritura de la prueba fallida, el paso verde es la modificación del software que hace que la prueba pase y el paso de refactorización es la mejora del código sin añadir funcionalidad, ayudado por la batería de pruebas existente, que proporciona confianza en que no estamos perdiendo funcionalidad del software sin darnos cuenta.

Por qué y para qué
------------------
El motivo más importante footnote:[_Para mí_ el más importante, seguro que otros discreparán.] para desarrollar dirigido por pruebas es el énfasis en la función de nuestro código y en su idoneidad para ponerlo a prueba y por lo tanto usarlo. Este énfasis nos obliga a preguntarnos cada vez que vamos a añadir código de explotación: ¿es esto lo que necesito? ¿hace falta _ahora_?; ayudándonos a escribir exclusivamente lo que necesitamos y a mantener el tamaño y la complejidad del código al mínimo necesario.

Si bien TDD no exime de buscar y dirigir el diseño deliberadamente, escribir código que, desde el primer momento, es fácil de probar favorece una cierta simplicidad y, definitivamente, evidencia el acoplamiento, guiándonos hacia el cuidado de la colaboración entre las unidades. En particular, la inyección de dependencias y la separación entre sus interfaces y las implementaciones, emergen de forma natural, dado que facilitan las pruebas automatizadas.

Los proyectos que se desarrollan dirigidos por pruebas cuentan en todo momento con una batería de pruebas al día, que documenta la intención de cada unidad del software, de combinaciones de unidades y del software en su totalidad. Además, las pruebas, si bien no la garantizan, dan una buena indicación de la corrección del software; lo que reduce el miedo a romper algo, y lo sustituye por un hábito diligente de refactorizar con frecuencia y mejorar el diseño progresivamente.


Ejemplos
~~~~~~~~
Por ejemplo el siguiente traductor es muy difícil de probar, y por lo tanto, de desarrollar con TDD.

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example1coupled/SpanishIntoEnglishTranslator.scala[example1coupled/SpanishIntoEnglishTranslator.scala]
[source,scala]
-----------------------------------------------------------------------------
class SpanishIntoEnglishTranslator {
  def translate(spanish: String) {
    println(spanish.split(' ').map(_ match {
      case "yo" => "I"
      case "soy" => "am"
      case _ => "mmmeh"
    }).reduceLeft(_ + " " + _))
  }
}
-----------------------------------------------------------------------------

Si lo desarrollamos con la facilidad de prueba en mente desde el principio, probablemente nos encontraremos con que, para probar el resultado de la traducción, necesitamos que el código que traduce devuelva el resultado; de hecho, ¿acaso no es la traducción en sí la responsabilidad principal de esta clase, y no el mostrar por pantalla? Si pudiéramos obtener el resultado, una prueba de nuestro traductor podría ser algo así:

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example2/SpanishIntoEnglishTranslatorTest.scala[example2/SpanishIntoEnglishTranslatorTest.scala]
[source,scala]
-----------------------------------------------------------------------------
var translator: SpanishIntoEnglishTranslator = _

before {
  translator = new SpanishIntoEnglishTranslator()
}

test("translates what it can") {
  translator.translate("yo soy") should be("I am")
}

test("mmmehs what it can't") {
  translator.translate("dame argo") should be("mmmeh mmmeh")
}
-----------------------------------------------------------------------------

Lo que nos llevaría a un traductor menos acoplado a la muestra por pantalla

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example2/SpanishIntoEnglishTranslator.scala[example2/SpanishIntoEnglishTranslator.scala]
[source,scala]
-----------------------------------------------------------------------------
class SpanishIntoEnglishTranslator {
  def translate(spanish: String): String =
    spanish.split(' ').map(_ match {
      case "yo" => "I"
      case "soy" => "am"
      case _ => "mmmeh"
    }).reduceLeft(_ + " " + _)
}
-----------------------------------------------------------------------------

Aún así, nuestro traductor hace unas cuantas cosas: separar frases en palabras, traducir las palabras y juntarlas otra vez... ¿Quizá la clase que se encarga de descomponer y componer debería ser distinta de la que traduzca palabra por palabra?

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example3/TranslatorTest.scala[example3/TranslatorTest.scala]
[source,scala]
-----------------------------------------------------------------------------
var translator: Translator = _

before {
  val dictionary: (String => String) = _ match {
    case "bueno" => "scorchio"
    case "cerveza" => "pissed"
    case _ => "changeplease"
  }
  translator = new Translator(dictionary)
}

test("translates word by word according to dictionary") {
  translator.translate("soy bueno") should be("changeplease scorchio")
}
-----------------------------------------------------------------------------

El traductor que nos queda está más centrado en descomponer y componer, y es independiente del diccionario.

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example3/Translator.scala[example3/Translator.scala]
[source,scala]
-----------------------------------------------------------------------------
class Translator(val dictionary: (String) => String) {
  def translate(spanish: String): String =
    spanish.split(' ').map(dictionary).reduceLeft(_ + " " + _)
}
-----------------------------------------------------------------------------

Este diseño está más preparado para acrecentar la funcionalidad; por ejemplo, si quisiéramos que la división en palabras tuviera en cuenta signos de puntuación, sólo necesitaríamos incrementear la complejidad de la clase +Translator+, encargada de la descomposición y recomposición de palabras; permitiéndonos no tener que pensar en el diccionario al mismo tiempo.

Crítica
~~~~~~~
En realidad aquí estamos ilustrando también una de las principales críticas contra el desarrollo dirigido por pruebas: Para poder probar la clase de traducción satisfactoriamente la hemos descompuesto en un diccionario y un desensamblador/ensamblador de palabras, pero si de verdad fuéramos a diseñar un sistema de traducción automatizada esta abstracción no sería apropiada: el diccionario necesita el contexto, la disposición de palabras en el texto resultante depende de la función gramatical, etc. ¿Significa esto que el TDD nos ha guiado en la dirección incorrecta? Yo diría que una cosa no quita la otra: como mencionamos antes, el TDD no nos exime de diseñar nuestro software; en este caso podría considerarse que la distinción de abstracciones ha sido prematura, que no hemos tenido en cuenta la dirección general en la que vamos... O incluso que siempre podemos empezar con una visión simplista y evolucionar el diseño a medida que nuestro modelo y compresión del problema se vuelven más sofisticados; con la confianza que nos da nuestra batería de pruebas, resultará más fácil evolucionar nuestro diseño incrementalmente, pasando de un sistema que funciona a un otro sistema que funciona, y que hace quizá un poco más que el anterior.
