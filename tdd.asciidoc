Desarrollo dirigido por pruebas
===============================
Joaquín Caraballo

El desarrollo dirigido por pruebas (o TDD por sus siglas en inglés) consiste en escribir la prueba que demuestra una característica del software antes de la característica en sí; de forma incremental, se va acrecentando una batería de pruebas con el código para explotación, al ritmo de

__________________________
rojo - verde - refactoriza
__________________________

Donde el paso rojo es la escritura de la prueba fallida, el paso verde es la modificación del software que hace que la prueba pase y el paso de refactorización es la mejora del código sin añadir funcionalidad, ayudado por la batería de pruebas existente, que proporciona confianza en que no estamos perdiendo funcionalidad del software sin darnos cuenta.

Por qué y para qué
------------------

El motivo más importante footnote:[_Para mí_ el más importante, seguro que otros discreparán.] para desarrollar dirigido por pruebas es el énfasis en la función de nuestro código y en su idoneidad para ponerlo a prueba y por lo tanto usarlo. Este énfasis nos obliga a preguntarnos cada vez que vamos a añadir código de explotación: ¿es esto lo que necesito? ¿hace falta _ahora_?; ayudándonos a escribir exclusivamente lo que necesitamos y a mantener el tamaño y la complejidad del código al mínimo necesario.

Si bien TDD no exime de buscar y dirigir el diseño deliberadamente, sí que favorece una cierta simplicidad y definitivamente revela el acoplamiento desde el principio, guiándonos hacia el cuidado de la colaboración entre las unidades. En particular la inyección de dependencias y la separación entre sus interfaces y las implementaciones emergen desde el principio de forma natural, dado que hacen más fácil escribir las pruebas.

Por ejemplo el siguiente traductor es muy difícil de probar, y por lo tanto, de desarrollar con TDD.

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example1coupled/SpanishIntoEnglishTranslator.scala[example1coupled/SpanishIntoEnglishTranslator.scala]
[source,scala]
-----------------------------------------------------------------------------
class SpanishIntoEnglishTranslator {
  def translate(spanish: String) {
    println(spanish.split(' ').map(_ match {
      case "yo" => "I"
      case "soy" => "am"
      case _ => "mmmeh"
    }).reduceLeft(_ + " " + _))
  }
}
-----------------------------------------------------------------------------

Si lo desarrollamos con la facilidad de prueba en mente desde el principio, probablemente nos encontraremos con que, para probar el resultado de la traducción, necesitamos que el código que traduce devuelva el resultado; de hecho, ¿acaso no es la traducción en sí la responsabilidad principal de esta clase, y no el mostrar por pantalla? Si pudiéramos obtener el resultado, una prueba de nuestro traductor podría ser algo así:

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example2/SpanishIntoEnglishTranslatorTest.scala[example2/SpanishIntoEnglishTranslatorTest.scala]
[source,scala]
-----------------------------------------------------------------------------
var translator: SpanishIntoEnglishTranslator = _

before {
  translator = new SpanishIntoEnglishTranslator()
}

test("translates what it can") {
  translator.translate("yo soy") should be("I am")
}

test("mmmehs what it can't") {
  translator.translate("dame argo") should be("mmmeh mmmeh")
}
-----------------------------------------------------------------------------

Lo que nos llevaría a un traductor menos acoplado a la muestra por pantalla

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example2/SpanishIntoEnglishTranslator.scala[example2/SpanishIntoEnglishTranslator.scala]
[source,scala]
-----------------------------------------------------------------------------
class SpanishIntoEnglishTranslator {
  def translate(spanish: String): String =
    spanish.split(' ').map(_ match {
      case "yo" => "I"
      case "soy" => "am"
      case _ => "mmmeh"
    }).reduceLeft(_ + " " + _)
}
-----------------------------------------------------------------------------

Aún así, nuestro traductor hace unas cuantas cosas: separar frases en palabras, traducir las palabras y juntarlas otra vez... ¿Quizá la clase que se encarga de descomponer y componer debería ser distinta de la que traduzca palabra por palabra?

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example3/TranslatorTest.scala[example3/TranslatorTest.scala]
[source,scala]
-----------------------------------------------------------------------------
var translator: Translator = _

before {
  val dictionary: (String => String) = _ match {
    case "bueno" => "scorchio"
    case "cerveza" => "pissed"
    case _ => "changeplease"
  }
  translator = new Translator(dictionary)
}

test("translates word by word according to dictionary") {
  translator.translate("soy bueno") should be("changeplease scorchio")
}
-----------------------------------------------------------------------------

Lo que nos lleva a un diseño menos acoplado

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example3/Translator.scala[example3/Translator.scala]
[source,scala]
-----------------------------------------------------------------------------
class Translator(val dictionary: (String) => String) {
  def translate(spanish: String): String =
    spanish.split(' ').map(dictionary).reduceLeft(_ + " " + _)
}
-----------------------------------------------------------------------------


 
