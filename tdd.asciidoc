Desarrollo dirigido por pruebas
===============================
Joaquín Caraballo

Desarrollo dirigido por pruebas
-------------------------------
El desarrollo dirigido por pruebas (o TDD por sus siglas en inglés) consiste en escribir la prueba que demuestra una característica del software antes de la característica en sí; de forma incremental, se va acrecentando una batería de pruebas con el código para explotación, al ritmo de

__________________________
rojo - verde - refactoriza
__________________________

Donde el paso rojo es la escritura de la prueba fallida, el paso verde es la modificación del software que satisface la prueba y el paso de refactorización es la mejora del código sin añadir funcionalidad, ayudado por la batería de pruebas existente, que proporciona confianza en que no estamos perdiendo funcionalidad del software sin darnos cuenta. footnote:[mencionar el diseño incremental un poco más]

Ejemplo
~~~~~~~
Probablemente la forma más fácil de explicar TDD es a nivel unitario. Supongamos que nuestra aplicación necesita convertir millas a kilómetros; empezamos con una prueba:

Rojo
^^^^
.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example0/MilesToKilometersConverterTest.scala[example0/MilesToKilometersConverterTest.scala]
[source,scala]
-----------------------------------------------------------------------------
test("Converts miles into kilometers"){
  MilesToKilometersConverter.convert(1.0) should be (1.609)
}
-----------------------------------------------------------------------------

A continuación, como estamos usando para los ejemplos Scala, que es un lenguaje compilado, antes  de poder ejecutar las pruebas necesitamos escribir un poco más de código. Nos limitaremos a añadir el mínimo código de explotación necesario para que compile. footnote:[Si estamos usando un entorno, la función de _arreglo_ hará la mayor parte del trabajo por nosotros. En muchos lenguajes como Scala, el compilador nos obligará a incluir alguna implementación antes de permitirnos ejecutar. Algunos desarrolladores suelen implementar inicialmente los métodos lanzando una excepción como en el ejemplo, lo que ayuda a mantener la separación rojo-verde, ya que no se piensa en la implementación hasta el paso verde. Aunque esto pueda parecer prolijo, resulta bastante rápido de producir si tenemos preparada una plantilla en nuestro entorno que introducimos con un atajo. Otra opción es generar la implementación más sencilla que se nos ocurra --por ejemplo devolviendo +0+ o +null+--]

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example0/MilesToKilometersConverter.scala[example0/MilesToKilometersConverter.scala]
[source,scala]
-----------------------------------------------------------------------------
object MilesToKilometersConverter {
  def convert(miles: Double): Double = 
    throw new RuntimeException("Not yet implemented")
}
-----------------------------------------------------------------------------

Para terminar el paso rojo, ejecutamos la prueba, comprobando que falla (lo que muchos entornos marcan en rojo) lanzando la excepción que esperábamos:

-----------------------------------------------------------------------------
Not yet implemented
java.lang.RuntimeException: Not yet implemented
	at org.casa.translation.example0.MilesToKilometersConverter$.convert(MilesToKilometersConverter.scala:4)
	at org.casa.translation.example0.MilesToKilometersConverterTest$$anonfun$1.apply$mcV$sp(MilesToKilometersConverterTest.scala:8)
-----------------------------------------------------------------------------

Aunque este paso parezca trivial, nos ha obligado a tomar unas cuantas decisiones importantes:

Primero, nos ha obligado a definir el contrato de uso del conversor; en este caso, el nombre sugiere que convierte específicamente millas a kilómetros, y no a la inversa; el método de conversión forma parte del _objeto_ (y no de la clase) +MilesToKilometersConverter+, por lo que no hay que instanciar el conversor, y sugiere que no tiene estado, las millas están expresadas con tipo +Double+, etc.

Segundo y más fundamental, hemos comenzado a definir la funcionalidad de la unidad, con un ejemplo que nos protege en cierta manera de las ambigüedades del lenguaje natural. Por ejemplo, no dudaremos de la definición de milla:
______________
Cuando dijimos millas, ¿eran millas internacionales (1,609km)? ¿Millas náuticas (1,852km)? ¿Millas nórdicas (10km)?
______________

Porque la prueba ha dejado claro que el tipo de milla que importa en nuestra aplicación _es igual a 1,609 kilómetros._

Aunque a veces parezca innecesario, merece la pena, antes de progresar al paso verde, completar el rojo llegando a ejecutar una prueba que _sabemos_ que va a fallar; esto nos obliga a pensar en la interfaz que estamos creando, y con frecuencia desvela suposiciones erróneas... especialmente cuando resulta que la prueba no falla, o que lo hace de una forma distinta de la que esperábamos.

Verde
^^^^^
A continuación acrecentamos el código de explotación. Lo más purista es escribir sólo el código imprescindible para superar la prueba: 

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example0/MilesToKilometersConverter.scala[example0/MilesToKilometersConverter.scala]
[source,scala]
-----------------------------------------------------------------------------
object MilesToKilometersConverter {
  def convert(miles: Double): Double = 1.609
}
-----------------------------------------------------------------------------

Y ejecutar la prueba, que nuestra implementación superará con un color verde, si usamos un entorno que lo represente así. footnote:[Más despacio: con http://www.informit.com/articles/article.aspx?p=30641[triangulación]; más deprisa: saltándose el paso verde inicial. Recortes:
Y a continuación ejecutar la prueba, añadir otra prueba con otro valor, ejecutarla y a continuación refactorizar la implementación para que cumpla varias pruebas y la funcionalidad general. Esto es lo que Kent Beck llama triangulación y es la versión más conservadora de la programación dirigida por pruebas. La mayoría de los programadores, cuando lo que desarrollan con TDD está claro, como es el caso, se saltan la triangulación (e incluso el paso verde, pero eso es más delicado)]

Rojo
^^^^
Antes de saltar a la implementación general, merece la pena que consideremos otras condiciones de entrada: ¿aceptamos distancias negativas? Como en este caso sí las aceptamos, lo expresamos con otra prueba.

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example0/MilesToKilometersConverterTest.scala[example0/MilesToKilometersConverterTest.scala]
[source,scala]
-----------------------------------------------------------------------------
test("Converts miles into kilometers"){
  MilesToKilometersConverter.convert(-2.0) should be (-3.218)
}
-----------------------------------------------------------------------------

Ejecutamos las pruebas para ver como la nueva falla.

-----------------------------------------------------------------------------
1.609 was not equal to -3.218
org.scalatest.TestFailedException: 1.609 was not equal to -3.218
-----------------------------------------------------------------------------

Verde
^^^^^
Ahora que tenemos dos ejemplos de la funcionalidad de +convert+, es un buen momento para buscar una implementación más general footnote:[A esta generalización Kent Beck la llama _triangulación_. No estoy seguro de que me guste el término, porque la triangulación a la que hace analogía permite de forma determinista encontrar una posición a partir de los datos de que se dispone. Aquí, sin embargo, los ejemplos por sí solos no nos permitirían encontrar la solución general, que precisa que además entendamos el problema más allá de los ejemplos.] que no sólo satisfaga estas dos pruebas, sino que también nos proporcione la funcionalidad general de la que son ejemplo. Como la siguiente:

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example0/MilesToKilometersConverter.scala[example0/MilesToKilometersConverter.scala]
[source,scala]
-----------------------------------------------------------------------------
object MilesToKilometersConverter {
  def convert(miles: Double): Double = miles * 1.609
}
-----------------------------------------------------------------------------

Refactorización
^^^^^^^^^^^^^^^
Tras cada paso verde debemos plantearnos la mejora del código, con la confianza de que las pruebas nos van a proteger de romper algo que funcionaba anteriormente. Las refactorizaciones pueden centrarse en el detalle (¿es mejor expresar +miles * 1.609+ o +1.609 * miles+? ¿el parámetro debería llamarse +miles+ o +distanceInMiles+?), pero es fundamental que con frecuencia también reconsideremos el diseño del la aplicación, evolucionándolo a lo que sea más apropiado para el estado actual del código, sin ignorar la dirección futura en la que quermos ir pero sin fraguar demasiado lo que puede que nunca necesitemos.


Por qué y para qué
------------------
El motivo más importante footnote:[_Para mí_ el más importante, seguro que otros discreparán.] para desarrollar dirigido por pruebas es el énfasis en la función de nuestro código y en su idoneidad para ponerlo a prueba y por lo tanto usarlo. Este énfasis nos obliga a preguntarnos cada vez que vamos a añadir código de explotación: ¿es esto lo que necesito? ¿hace falta _ahora_?; ayudándonos a escribir exclusivamente lo que necesitamos y a mantener el tamaño y la complejidad del código al mínimo necesario.

Si bien TDD no exime de buscar y dirigir el diseño deliberadamente, escribir código que, desde el primer momento, es fácil de probar favorece una cierta simplicidad y, definitivamente, evidencia el acoplamiento, guiándonos hacia el cuidado de la colaboración entre las unidades. En particular, la inyección de dependencias y la separación entre sus interfaces y las implementaciones, emergen de forma natural, dado que facilitan las pruebas automatizadas.

Los proyectos que se desarrollan dirigidos por pruebas cuentan en todo momento con una batería de pruebas al día, que documenta la intención de cada unidad del software, de combinaciones de unidades y del software en su totalidad. Además, las pruebas, si bien no la garantizan, dan una buena indicación de la corrección del software; lo que reduce el miedo a romper algo, y lo sustituye por un hábito diligente de refactorizar con frecuencia y mejorar el diseño progresivamente.


Ejemplos
~~~~~~~~
Por ejemplo el siguiente traductor es muy difícil de probar, y por lo tanto, de desarrollar con TDD.

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example1coupled/SpanishIntoEnglishTranslator.scala[example1coupled/SpanishIntoEnglishTranslator.scala]
[source,scala]
-----------------------------------------------------------------------------
class SpanishIntoEnglishTranslator {
  def translate(spanish: String) {
    println(spanish.split(' ').map(_ match {
      case "yo" => "I"
      case "soy" => "am"
      case _ => "mmmeh"
    }).reduceLeft(_ + " " + _))
  }
}
-----------------------------------------------------------------------------

Si lo desarrollamos con la facilidad de prueba en mente desde el principio, probablemente nos encontraremos con que, para probar el resultado de la traducción, necesitamos que el código que traduce devuelva el resultado; de hecho, ¿acaso no es la traducción en sí la responsabilidad principal de esta clase, y no el mostrar por pantalla? Si pudiéramos obtener el resultado, una prueba de nuestro traductor podría ser algo así:

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example2/SpanishIntoEnglishTranslatorTest.scala[example2/SpanishIntoEnglishTranslatorTest.scala]
[source,scala]
-----------------------------------------------------------------------------
var translator: SpanishIntoEnglishTranslator = _

before {
  translator = new SpanishIntoEnglishTranslator()
}

test("translates what it can") {
  translator.translate("yo soy") should be("I am")
}

test("mmmehs what it can't") {
  translator.translate("dame argo") should be("mmmeh mmmeh")
}
-----------------------------------------------------------------------------

Lo que nos llevaría a un traductor menos acoplado a la muestra por pantalla

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example2/SpanishIntoEnglishTranslator.scala[example2/SpanishIntoEnglishTranslator.scala]
[source,scala]
-----------------------------------------------------------------------------
class SpanishIntoEnglishTranslator {
  def translate(spanish: String): String =
    spanish.split(' ').map(_ match {
      case "yo" => "I"
      case "soy" => "am"
      case _ => "mmmeh"
    }).mkString(" ")
}
-----------------------------------------------------------------------------

Aún así, nuestro traductor hace unas cuantas cosas: separar frases en palabras, traducir las palabras y juntarlas otra vez... ¿Quizá la clase que se encarga de descomponer y componer debería ser distinta de la que traduzca palabra por palabra?

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/test/scala/org/casa/translation/example3/TranslatorTest.scala[example3/TranslatorTest.scala]
[source,scala]
-----------------------------------------------------------------------------
var translator: Translator = _

before {
  val dictionary: (String => String) = _ match {
    case "bueno" => "scorchio"
    case "cerveza" => "pissed"
    case _ => "changeplease"
  }
  translator = new Translator(dictionary)
}

test("translates word by word according to dictionary") {
  translator.translate("soy bueno") should be("changeplease scorchio")
}
-----------------------------------------------------------------------------

El traductor que nos queda está más centrado en descomponer y componer, y es independiente del diccionario.

.https://www.assembla.com/code/tdd-examples/git/nodes/master/src/main/scala/org/casa/translation/example3/Translator.scala[example3/Translator.scala]
[source,scala]
-----------------------------------------------------------------------------
class Translator(val dictionary: (String) => String) {
  def translate(spanish: String): String =
    spanish.split(' ').map(dictionary).mkString(" ")
}
-----------------------------------------------------------------------------

Este diseño está más preparado para acrecentar la funcionalidad; por ejemplo, si quisiéramos que la división en palabras tuviera en cuenta signos de puntuación, sólo necesitaríamos incrementear la complejidad de la clase +Translator+, encargada de la descomposición y recomposición de palabras; permitiéndonos no tener que pensar en el diccionario al mismo tiempo.

Crítica
~~~~~~~
En realidad aquí estamos ilustrando también una de las principales críticas contra el desarrollo dirigido por pruebas: Para poder probar la clase de traducción satisfactoriamente la hemos descompuesto en un diccionario y un desensamblador/ensamblador de palabras, pero si de verdad fuéramos a diseñar un sistema de traducción automatizada esta abstracción no sería apropiada: el diccionario necesita el contexto, la disposición de palabras en el texto resultante depende de la función gramatical, etc. ¿Significa esto que el TDD nos ha guiado en la dirección incorrecta? Yo diría que una cosa no quita la otra: como mencionamos antes, el TDD no nos exime de diseñar nuestro software; en este caso podría considerarse que la distinción de abstracciones ha sido prematura, que no hemos tenido en cuenta la dirección general en la que vamos... O incluso que siempre podemos empezar con una visión simplista y evolucionar el diseño a medida que nuestro modelo y compresión del problema se vuelven más sofisticados; con la confianza que nos da nuestra batería de pruebas, resultará más fácil evolucionar nuestro diseño incrementalmente, pasando de un sistema que funciona a un otro sistema que funciona, y que hace quizá un poco más que el anterior.


Cómo desarrollar dirigido por pruebas
-------------------------------------
Mantener la batería verde
~~~~~~~~~~~~~~~~~~~~~~~~~
La batería de pruebas es la documentación de la funcionalidad de nuestro código. Una documentación que se mantiene al día, porque va creciendo con cada cambio y es ejercitada, es decir, ejecutamos las pruebas, al menos con cada envío de los cambios al repositorio. 

Trabajar dirigido por pruebas significa mantener siempre el correcto funcionamiento del sistema; idealmente la última versión en el repositorio común deberá estar en todo momento lista para ponerla en explotación, y las pruebas satisfechas en todo momento footnote:[De hecho, algunos equipos hacen exactamente eso, ponen cada versión que satisface la batería completa automáticamente en explotación -- _cita... continuous deployment, etc._], con lo que la documentación proporcionada por las pruebas estará siempre al día. Para lograrlo, deberemos comprobar la satisfacción de las pruebas antes de enviar cualquier cambio al repositorio común; muchos equipos ayudándose además de un sistema de integración continua que verifica automáticamente la batería cada vez que se detecta un cambio en el repositorio.

Probar una sola cosa cada vez
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
El mantenimiento de la batería de pruebas, que crece con la aplicación, 
A medida que crece la aplicación, con ella aumenta la batería; la calidad de nuestras pruebas determinará en gran medida el coste de mantenerlas al día. Uno de los aspectos que hacen costoso el mantenimiento de las pruebas es la verificación de varios aspectos independientes en la misma prueba. Esto se suele manifestar cuando un cambio pequeño en el código de explotación requiere retocar un gran número de pruebas.

# método con un par de funcionalidades
# inicialización o paso previo común


Recortes
~~~~~~~~

A medida que crece la aplicación, con ella aumenta la batería



para mantener la factibilidad de esta tarea es necesario que el equipo invierta un esfuerzo continuo en mantener reducido el tiempo de ejecución de la batería y corregir fallos intermitentes, cuando se da el caso; las soluciones dependen del proyecto en sí, incluyendo a veces algunas de compromiso como relegar parte de las pruebas a un sistema de integración continua que las verificará cada vez que se detecte un cambio en el repositorio.


Al comienzo de la vida del proyecto, deberemos asegurarnos de satisfacer todas las pruebas antes de enviar cualquier cambio al repositorio. A medida que crece la aplicación, el tiempo que requiere la batería completa tiende a aumentar. Puesto que es importante enviar cambios al repositorio con frecuencia, deberemos esforzarnos en mantener reducido este tiempo, para limitar el coste e incentivar la satisfacción rigurosa de las pruebas antes de enviar los cambios; la manera de lograrlo va más allá de un artículo introductorio; pero incluye la selección y el ajuste de la tecnología empleada para los distintos elementos de la batería, la ejecución en paralelo e incluso la partición de la aplicación en sí o cualquier ajuste que la haga más rápida. 

Lo ideal será que ejecutemos todas las pruebas antes de enviar cualquier cambio al repositorio, particularmente cuando el proyecto está empezando y la batería se ejecuta rápidamente. A medida que crece la aplicación y con ella su batería de pruebas, con frecuencia se transige y se acuerda cuál es el mínimo grupo de pruebas a incluir en una _batería rápida_, que se deberá ejecutar antes de enviar cualquier cambio al repositorio. El resto de pruebas se relega a un _sistema de integración continua_, que se encargará de ejecutar automáticamente la totalidad de la batería con cada cambio detectado en el repositorio. Hayamos acordado con nuestro equipo ejecutar la batería completa o una batería rápida, antes de enviar cambios al repositorio comun, es importante crear en el equipo una cultura en la que los desarrolladores muestran respeto por sus compañeros evitando romper tanto la batería rápida como el resto de las pruebas y cualquier otra funcionalidad de la aplicación en desarrollo.

