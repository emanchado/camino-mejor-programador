Introducción al diseño de APIs REST con HTTP
============================================
Enrique J. Amodeo_Rubio <eamodeorubio@gmail.com>
:Blog: http://eamodeorubio.wordpress.com
:Twitter: @eamodeorubio

Introducción
------------

Tras muchos años intentando crear servicios web basados en tecnologías RPC como CORBA o SOAP, la industria del desarrollo de software se encontraba en un punto muerto. Cierto, se había conseguido hacer que un servicio implementado en .NET consiguiera comunicarse con uno escrito en Java, o incluso con otro hecho a base de COBOL, sin embargo todo esto sabía a poco. Es normal que supiera a poco, se había invertido cantidades ingentes de dinero en distintas tecnologías, frameworks y herramientas, y las recompensas eran escasas. Lo peor es que además las compañías se encontraban encalladas en varios problemas.

Por un lado la mantenibilidad de la base de código resultante era bastante baja. Se necesitaban complejos IDEs para generar las inescrutables toneladas de código necesarias para interoperar. Los desarrolladores tenían pesadillas con la posibilidad de que se descubriera algún bug en la herramienta de turno, o de que algún parche destruyera la interoperabilidad. Y si se necesitaba alguna versión o capacidad más avanzada de SOAP probablemente el IDE no lo soportara o tuviera que ser actualizado.

Por otro lado para depurar cualquier problema de interoperabilidad había que bajar al nivel de HTTP: ¿estarían las cabeceras apropiadas? ¿La serialización del documento SOAP es conforme a "Basic Profile"[3]? ¿No se suponía que SOAP era transparente al protocolo?

Finalmente también había descontento. Se había soñado con un mundo de servicios web interoperables de manera transparente, organizados en directorios UDDI y demás. Al final esto no se consiguió, sólo interoperaban servicios entre distintos departamentos de una misma empresa, o de forma más rara algún servicio llamaba a otro servicio de otra empresa, todo con mucho cuidado y en condiciones bastante frágiles.

Cuando la situación se hizo insostenible, y algunos gigantes de la informática como Amazon, Google o Twitter necesitaron interoperabilidad a escala global y barata, alguien descubrió el camino al futuro mirando hacia el pasado, y descubrió REST...

¿Qué es REST?
~~~~~~~~~~~~~

REST[1] no es una tecnología, ni siquiera una arquitectura, REST es un estilo arquitectónico. Es un conjunto de restricciones a respetar cuando diseñamos la arquitectura de nuestros servicios web. Las restricciones propuestas por REST son las siguientes:

* REST no es RPC, sino orientado a recursos. Los servicios web no representan acciones, sino entidades de negocio. En vez de publicar verbos como por ejemplo "comprar", se publican nombres como "carrito de la compra" o "pedido". En este sentido podemos pensar en RPC como intentar definir la API de un sistema en base a procedimientos, es decir, es un paradigma procedural. Sin embargo REST define la API como un conjunto de recursos que representan objetos de negocio; este enfoque está mucho más cercano a la OO que a otra cosa. En lo sucesivo usaré las palabras "recurso", "entidad" y "servicio" de forma intercambiable, aunque realmente la más correcta es "recurso".
* Cada recurso posee un identificador único universal (UUID o GUID) con el cual podemos hacer referencia a él. Estas referencias las puede usar un cliente para acceder al recurso, o bien puede usarse para crear una relación desde un recurso a otro. Crear estas relaciones es tan sencillo como incluir una referencia de un recurso a otro usando el UUID del último.
* La implementación, y la forma exacta en la que un recurso se representa internamente, debe ser privada y no accesible al exterior.
* Cada recurso tiene un interfaz, o conjunto de operaciones que admite. Basta saber el UUID del recurso para poder enviarle la operación que queremos realizar. 
* La interfaz es homogénea para todos los recursos. Esto quiere decir que todos los recursos deben escoger las operaciones que soportan de un conjunto de acciones predefinidos. Este conjunto de operaciones permitidas es una característica específica de cada arquitectura REST y no puede cambiarse. Como consecuencia no podemos inventar nuevas operaciones, sino que tenemos que modelar esas nuevas operaciones como recursos. Por ejemplo, en un sistema REST no podemos añadir una operación "reservarHotel", sino que tendríamos que crear un nuevo recurso llamado "ReservaDeHotel". Sin embargo el conjunto de operaciones mínimo que debe tener un sistema REST es "leer", "actualizar" y "crear".
* Las operaciones se realizan mediante transferencia de estado del recurso. El cliente puede pedir que una copia del estado de un recurso sea transferido desde el servidor al cliente (leer), modificarlo, y mandar la copia modificada al servidor usando alguna de las operaciones de modificación permitidas (actualizar o crear).
* Las operaciones son _stateless_. Es decir, el resultado de una operación es independiente de la conversación que hayan mantenido el cliente y el servidor anteriormente. Como consecuencia de esto toda la información necesaria para llevar a cabo la operación debe mandarse como parámetros de ésta.
* Los recursos son multimedia, es decir, el estado de un recurso puede ser representado mediante distintos formatos. Por formato se entiende el formato concreto de serialización del estado cuando se manda por red. Algunos ejemplos de formatos son XML, JSON, imagen JPEG, imagen GIF, etc. Como vimos antes el estado de un recurso puede ser copiado desde un servidor al cliente o viceversa, pero por otro lado el formato interno del recurso es privado y desconocido por el cliente. Para que esto funcione el cliente debe especificar al servidor que formatos entiende y viceversa, y ponerse de acuerdo en el conjunto de formatos más conveniente a usar que ambas partes entiendan.

REST es el acrónimo para "REpresentational State Transfer". Veamos lo que significa con un pequeño ejemplo de como sería la reserva de una habitación de hotel usando REST:

1. El cliente pide (leer) el recurso "Habitaciones" realizando una operación leer contra el servidor. En dicha operación se pasan parámetros correspondientes al rango de fechas de disponibilidad y características de la habitación.
2. El servidor responde con un documento representando un resumen de la lista de habitaciones que conforman a los criterios de búsqueda. El resumen de cada habitación contiene el UUID de ésta, y el UUID de un recurso asociado que representa las reservas de dicha habitación.
3. El cliente opcionalmente puede pedir (leer) el detalle completo de cada habitación usando el UUID contenido en el resumen.
4. El cliente envía una operación de "crear" al recurso que representa las reservas de la habitación elegida. Recordemos que el UUID de este recurso estaba tanto en el resumen como en el detalle de cada habitación. Al enviar la operación pasa como parámetro los detalles de la reserva.
5. El servidor puede responder de varias formas:
    . Rechazando la petición.
    . Devolviendo el UUID del recurso que representa la reserva que acabamos de crear e indicando que la reserva está completa.
    . Devolviendo el UUID del recurso que representa la reserva que estamos creando, y además un documento donde se pide información adicional, tal vez detalles de forma de pago o nombre de los huéspedes. El cliente debería modificar el documento e invocar la operación "actualizar" contra el UUID. De ahí se volvería al paso 5.

Como se ve toda la dinámica se basa en una conversación entre el cliente y el servidor, donde el cliente pide una copia del estado del recurso al servidor, el servidor se lo devuelve en un formato concreto (documento), el cliente lo modifica y se lo vuelve a mandar al servidor. Esto a su vez puede terminar en modificar el estado del recurso o crear uno nuevo. A partir de ahí el servidor devuelve un nuevo documento con el resultado de la operación y quizás el UUID del nuevo recurso creado, y la conversación continúa. Ahora quizás se entienda el significado de "REpresentational State Transfer", ya que todas la operativa se basa en transferir una representación (formato de documento) del estado de un recurso entre el cliente y el servidor y viceversa.

¿Por qué usar REST?
~~~~~~~~~~~~~~~~~~~

¿Queremos diseñar un sistema de servicios web? Pues lo más sensato es ver como funciona la web e investigar cómo funciona el único caso de éxito de interoperabilidad a escala global que existe en la actualidad. ¿Cuál es tal caso de éxito? La world wide web. Sí querido lector, las páginas web que navegamos a diario son un caso real de interoperabilidad a escala global, sólo es necesario usar un navegador decente que entienda los formatos disponibles para cada página (HTML, GIF, JPEG, códecs de video, etc) para poder consumirlas. No importa que el fabricante del navegador y el autor de la página no hayan interactuado en la vida, o que cada autor de cada página sea totalmente independiente entre ellos.

El enfoque RPC basado en SOAP ha fracasado, no conozco ningún sistema basado en este paradigma que alcance niveles de interoperabilidad tan altos a costes tan bajos como la world wide web. Por lo tanto la world wide web es un ejemplo a seguir, una guía a las decisiones de diseño necesarias para hacer servicios interoperables.

Es trivial darse cuenta de que si quieres hacer servicios web, tienes que respetar los principios de diseño de la web y diseñar tus servicios con ellos en mente. ¿Cuáles son los principios arquitectónicos de la web? Los principios REST.

Llevando REST al mundo real
---------------------------

Vayamos a lo práctico, ¿cómo implementar REST en el mundo real?

El protocolo HTTP
~~~~~~~~~~~~~~~~~

El protocolo HTTP[2], pieza fundamental en la que se basa la world wide web, especifica como intercambiar entre cliente y servidor recursos web. Es un protocolo idóneo para implementar servicios web, ya que además de ser ubicuo, su diseño sigue los principios REST. Veamos ahora como funciona este protocolo y como encaja en el estilo arquitectónico REST.

HTTP es un protocolo que se sitúa al nivel de aplicación, incluyendo algo del nivel de presentación, dentro de la pila ISO[4]. En principio está diseñado para ser ejecutado sobre TCP o sobre transporte seguro TLS/SSL, aunque no sería descabellado mandar mensajes HTTP sobre otro protocolo de transporte. Se basa en un paradigma sencillo petición/respuesta, sin ningún tipo de memoria ni sesión de usuario, es decir, es un protocolo stateless.

El mensaje de petición en HTTP consta de una primera línea de texto indicando la versión del protocolo, el verbo HTTP y la URI destino. El verbo HTTP indica la operación a realizar sobre el recurso web localizado en la URI destino. Más adelante hablaremos más, tanto sobre los verbos que hay, como sobre las URIs. A continuación, y de forma opcional, vienen las cabeceras. Cada cabecera va en una línea de texto distinta, y consiste en el nombre de la cabecera seguido de su valor, ambos separados por ":". Opcionalmente la petición puede llevar un cuerpo, separado por una línea en blanco del encabezamiento del mensaje, y que contiene un documento. Dicho documento puede estar en cualquier formato (incluso binario), aunque normalmente suele ser texto plano, HTML, XML o JSON. El formato del documento se define en la cabecera "Content-Type".

Los mensajes de respuesta HTTP siguen el mismo formato que los de petición, excepto en la primera línea, donde se indica el código de respuesta y una explicación textual de dicha respuesta. El código de respuesta indica si la petición tuvo éxito o no y por qué razón.

Un ejemplo de petición HTTP sería:
------------------------------
POST /server/payment HTTP/1.1
Host: www.myserver.com
Content-Type: application/x-www-form-urlencoded
Accept: application/json
Accept-Encoding:gzip,deflate,sdch
Accept-Language:en-US,en;q=0.8
Cache-Control:max-age=0
Connection:keep-alive

orderId=34fry423&payment-method=visa&card-number=2345123423487648&sn=345
------------------------------

Y como respuesta:
------------------------------
HTTP/1.1 201 Created
Content-Type: application/json;charset=utf-8
Location: https://www.myserver.com/services/payment/3432
Cache-Control:max-age=21600
Connection:close
Date:Mon, 23 Jul 2012 14:20:19 GMT
ETag:"2cc8-3e3073913b100"
Expires:Mon, 23 Jul 2012 20:20:19 GMT

{
  "id":"https://www.myserver.com/services/payment/3432",
  "status": "pending"
}
------------------------------

Las URIs
^^^^^^^^

Las URI[5] son los identificadores globales de recursos en la web, y actúan de manera efectiva como UUIDs REST. Las URIs tiene el siguiente formato:

------------------------------
<esquema>:<parte específica esquema>/<ruta><querystring><fragmento>
------------------------------

El esquema, en el caso de una URL(\*), indica qué protocolo se debe usar para acceder al recurso. En el caso que nos ocupa podría ser "http", o "https" si usamos transporte seguro. Si es una URN(*) el esquema es "urn". En nuestro caso nos interesan las URLs, e ignoraremos las URNs en el resto de la discusión.

Tras el esquema, viene la parte específica del esquema. En las URLs sería la dirección del servidor donde se encuentra el recurso. Esta dirección se puede especificar mediante una dirección IP o mediante un nombre de dominio, y se separa del esquema mediante "//". Opcionalmente se especifica el puerto a usar en la conexión concatenándolo con ":". Esto no es necesario si se va a usar el puerto estándar del protocolo especificado. El puerto estándar para "http" es el 80 y para "https" es 443.

A continuación viene la ruta del recurso dentro del servidor. Tiene la forma de un conjunto de segmentos separados por "/"(**).

De forma opcional tenemos la "query string", que indica parámetros adicionales de la URI a ser procesados en el servidor por la aplicación. Su uso más común es el de especificar criterios de búsqueda o filtrado o bien añadir parámetros o tokens de control. La "query string" se separa de la ruta mediante el carácter "?" y consiste en una serie de pares clave/valor separados por "&". Dentro de cada para la clave y el valor se separa por "=".

Finalmente y también de forma opcional tenemos el fragmento, que se separa del resto de la URI mediante "#". Al contrario que la "query string" el fragmento no se procesa en servidor, sino que está pensado para ser procesado por la aplicación cliente. Por lo tanto no tiene impacto en el diseño de servicios web.

Las siguientes son todas URIs:
------------------------------
http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.2
https://www.myserver.com/rest/books?author=vega
ftp://user@ftp.server.com/dir/somefile.txt
urn:oasis:names:specification:docbook:dtd:xml:4.1.2
urn:uuid:a74fc10b-58cc-4379-f5c7-1e02b2a3d479
------------------------------

(*) Las URLs y URNs son casos concretos de URIs. Las primeras identifican un recurso de red mediante una IP o un DNS, las segundas son simples UUIDs lógicos con un espacio de nombres asociados. Para más detalle ver [5]

(**) Otras cosas pueden aparecer, para ello se usan otros caracteres como ";" o "@". Esto raramente se usa, con la interesante excepción del ";" para indicar el identificador de sesión servidora. Para más detalle ver [5]

Los verbos HTTP
^^^^^^^^^^^^^^^

Una característica completamente alineada con REST del protocolo HTTP es el hecho de que tenga una interfaz uniforme para todos los recursos web. HTTP define un conjunto predefinido y cerrado de acciones o métodos HTTP(*). Es importante tener en cuenta que la propia especificación define los conceptos de "seguridad" e "idempotencia", y clasifica los métodos conforme a estos dos criterios.

Un método se considera "seguro" si no produce efectos secundarios. Por efecto secundario se entiende cualquier modificación del estado del servidor o interacción de éste con cualquier otro sistema que produzca efectos perceptibles por el usuario. Normalmente sólo los métodos que representan lectura se consideran seguros.

Un método es idempotente, si la ejecución repetida de éste, con exactamente los mismos parámetros, tiene el mismo efecto que si sólo se hubiera ejecutado una vez. Esta propiedad nos permite reintentar con seguridad una petición una y otra vez y tener la seguridad de que la operación no se va a duplicar. De forma muy común, debido a cortes y congestiones de red, el cliente no recibe la confirmación de si una operación se ha realizado o no. Tal vez la petición ha llegado al servidor y se ha ejecutado, con lo que no deberíamos duplicar la operación, o tal vez simplemente se ha quedado por el camino y debemos reintentarla. Los métodos idempotentes nos permiten recuperarnos de esta circunstancia simplemente repitiendo la petición, ya que nos aseguran que no se duplicará la operación si estuviéramos en el primer caso.

Los métodos HTTP más comunes son los siguientes (**):

[options="header"]
|=======================================================================
| Método  |Seguro|Idempotente|        Semántica                         
| GET     |  Sí  |    Sí     | Leer el estado del recurso               
| HEAD    |  Sí  |    Sí     | Leer, pero sólo las cabeceras            
| PUT     |  No  |    Sí     | Actualizar o crear
| DELETE  |  No  |    Sí     | Eliminar un recurso                      
| POST    |  No  |    No     | Cualquier acción genérica no idempotente 
| OPTIONS |  Sí  |    Sí     | Averiguar las opciones disponibles de comunicación de un recurso
|=======================================================================

En general el uso de cada método es bastante explicativo, y más adelante veremos cómo usarlos así como buenas prácticas. Sin embargo conviene aclarar un par de aspectos. El primero es la diferencia entre HEAD y GET. Ambos leen el recurso, pero el segundo devuelve tanto los datos del recurso web, como las cabeceras HTTP, mientras que el primero sólo las cabeceras. Por otro lado el método POST es bastante misterioso y objeto de frecuentes malentendidos. En general se usa para crear un nuevo recurso, modificar uno existente o para ejecutar una acción genérica que no sea idempotente como realizar una transacción monetaria. Como veis la semántica de PUT parece que se solapa con la de POST de alguna manera, y esto es fuente de numerosos malentendidos. Más adelante aclararemos este tema.

El método OPTIONS se usa para determinar las opciones de comunicación de un recurso, tales como qué métodos HTTP podemos usar contra esa URI. El resultado de OPTIONS no es _cacheable_, ya que el conjunto de métodos que podemos usar puede cambiar con el estado en el que se encuentre el recurso. Junto con HEAD nos permiten descubrir automáticamente cómo podemos comunicarnos con el servidor.

(*) Los métodos HTTP también son llamados verbos HTTP en multitud de fuentes.
(**) Existen otros métodos que no suelen ser muy usados en servicios REST, como CONNECT o TRACE.

Los tipos MIME
^^^^^^^^^^^^^^

Otro aspecto muy apropiado para el desarrollo de servicios REST con el protocolo HTTP es su soporte para negociar distantos formatos (representaciones) a usar en la transferencia del estado entre servidor y cliente (y viceversa).

En HTTP cada uno de estos formatos se constituye lo que se llama un tipo MIME distinto y existen muchos tipos MIME estandarizados[6]. Cada tipo MIME tiene el formato de <tipo>/<subtipo>. Algunos tipos MIME muy usados: "application/json", "application/xml", "application/atom+xml", "application/javascript", "text/html" y "audio/vorbis".

A veces en el subtipo suele aparecer el caracter "+". Esto indica que el tipo MIME es una variante de otro tipo principal. Por ejemplo "application/atom+xml", indica que el tipo MIME es una variante del más genérico "application/xml" pero siguiendo el XML schema de atom. Otra convención común es que si el subtipo empieza por "x-" entonces el tipo MIME no es estándar, sino propietario.

¿Cómo se negocia el tipo MIME entre el cliente y el servidor? Es sencillo, en el mensaje de petición se incluye una cabecera "Accept", con una lista de tipos MIME que el cliente entiende, el servidor selecciona el tipo que más le interese de entre todos los especificados en la cabecera "Accept", y devuelve la respuesta. Si el servidor no entiende ninguno de los tipos MIME propuestos devuelve un mensaje con código 406, indicando que es incapaz de aceptar la petición. Si no se incluye la cabecera "Accept" se indica que se acepta cualquier tipo MIME. Por otro lado, ya sea en la petición como en la respuesta HTTP, la cabecera "Content-Type" debe contener el tipo MIME del documento que aparece en el cuerpo del mensaje. Si el mensaje no tiene cuerpo no debe aparecer dicha cabecera.

En la cabecera "Accept", la lista de tipos MIME se especifica mediante lo que se llama un "media range". Un "media range" es una lista separada por comas de tipos MIME, donde cada uno de los tipos MIME puede ir acompañados por uno o más parámetros. Para indicar un parámetro en un tipo MIME se usa el ";". Así "text/html;level=3" indica el tipo MIME "text/html" con un parámetro "level" con valor "3". En general el significado del parámetro es específico de cada tipo MIME. Un ejemplo de parámetro podría ser "charset" indicando la codificación de caracteres dentro de un formato de tipo texto o de tipo aplicación no binario. Ej. "text/plain; charset=ISO-8859-1" y "application/json; charset=UTF-8"

Además en un "media range" pueden aparecer expresiones de rango. Hay dos:

1. "\*/*" indica cualquier tipo MIME
2. "<tipo>/\*" indica cualquier subtipo dentro del tipo. Por ejemplo "image/*" indica cualquier imagen en cualquier formato.

Un "media range" no sólo especifica una lista de tipos MIME aceptables, sino tambien un orden de preferencia, de tal manera que el servidor debe intentar elegir el tipo MIME que soporte pero que tenga mayor preferencia para el cliente. La preferencia se calcula usando las siguientes reglas:

1. Si el tipo MIME tiene un parámetro llamado "q", usar el valor de ese parámetro como preferencia. Este valor debe estar entre 0 y 1, y el parámetro "q" debe ser el primero.
2. Si no existe parámetro "q", asumir que tiene un valor de 1.
3. Si hay empate en el valor de "q", el orden de preferencia para desempatar, de mayor a menor es el que sigue:
 a. El tipo MIME con mayor número de parámetros
 b. Las expresiones <tipo>/*
 c. La expresión \*/*

Pongamos un ejemplo, la siguiente cabecera:
---------------------------
Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, */*;q=0.5
---------------------------

Especifica el siguiente orden de preferencias de tipos MIME:

1. text/html;level=1
2. text/html
3. Cualquier formato que no sea texto
4. Cualquier formato de texto (text/*)

Códigos de estado
^^^^^^^^^^^^^^^^^

En HTTP el mensaje de respuesta contiene en su primera línea lo que se llama el código de estado, que indica el resultado de la operación. Los códigos de respuesta más usados son:

* 200. Indica éxito de la operación de forma genérica. Se usa cuando no hay otro código de éxito más específico. El mensaje de respuesta debe contener un cuerpo, en otro caso se usa 204.
* 201. Indica que se creó con éxito un nuevo recurso web. Suele devolverse cuando ejecutamos un método POST o PUT. En la respuesta se devuelve la URI del nuevo recurso creado dentro de la cabecera "Location". La respuesta puede contener un cuerpo con los datos del nuevo recurso.
* 202. Indica que la petición se ha aceptado pero que no está completa. Se puede devolver en la respuesta un cuerpo con información sobre cuanto queda para que se complete la operación o indicando como monitorizar el progreso de ésta. Es muy útil cuando el servidor esta congestionado o para modelar operaciones de larga duración.
* 204. Indica éxito de la operación de forma genérica. Se usa cuando no hay otro código de éxito más específico. El mensaje de respuesta está vacio y no tiene cuerpo, en otro caso usar 200.
* 301. Indica que el recurso se ha movido a otra URI de forma permanente. La nueva URI se indica en la cabecera "Location" de la respuesta. Este mecanismo de redirección se puede usar para versionar servicios como veremos más adelante.
* 304. Indica que el recurso no se ha modificado. Normalmente es la respuesta de un cache a una operación. La respuesta no contiene cuerpo.
* 400. El mensaje de petición está mal formado.
* 401. La petición no está autorizada, acceso denegado. Las credenciales de la petición son incorrectas (tal vez el usuario no existía o el esquema de autenticación no es correcto) o simplemente la petición no tenía credenciales. Indica la necesidad de volver a hacer la petición con unas credenciales correctas para autenticarse.
* 403. Acceso denegado: las credenciales son insuficientes para acceder al recurso, el usuario no tiene permiso.
* 404. Recurso no encontrado.
* 405. Método no soportado, la operación HTTP especificada en la petición no está implementada. Un ejemplo de esto sería al intentar actualizar un recurso de sólo lectura.
* 406. La petición no es aceptable. Tal vez el servidor no soporta los tipos MIME aceptados por el cliente.
* 409. Conflicto de versiones. Usado en la implementación de concurrencia optimista (ver más adelante).
* 412. Fallo en la precondición. Usado en la implementación de concurrencia optimista (ver más adelante).
* 500. Se produjo un error inesperado en el servidor. Se puede usar para modelar excepciones en la capa de aplicación.

El uso de muchos de estos códigos de estado es bastante evidente. Más adelante veremos algunos casos de uso concretos.

QoS en HTTP
^^^^^^^^^^^

Existen cabeceras en HTTP que tienen que ver con mejorar la eficiencia de la comunicación.

Por ejemplo, las cabeceras "Content-Encoding" y "Accept-Encoding" nos permiten modificar la codificación del cuerpo de los mensajes. Un caso práctico de esto es comprimir el cuerpo de los mensajes con el algoritmo GZIP para ahorrar ancho de banda.

La cabecera "Keep-Alive" nos permite reutilizar una misma conexión a nivel de transporte (un socket TCP por ejemplo) para varios ciclos de petición/respuesta. Sin esta cabecera cada petición/respuesta iría en una conexión diferente, lo que consumiría mayor cantidad de recursos y aumentaría la latencia.

La cabecera "Upgrade", nos permite cambiar a otro protocolo. Ahora está siendo usada principalmente para cambiar a protocolo WebSocket.

Una cabecera muy usada es "Transfer-Encoding", que nos permite enviar mensajes de longitud variable, lo que es indispensable para hacer streaming.

Afortunadamente como desarrolladores es improbable que tengamos que preocuparnos de todo esto, ya que se gestiona de forma casi transparente a través de la infraestructura. Sin embargo sí que hay aspectos de HTTP relacionados con la calidad de servicio, como la gestión de caché, la seguridad o la concurrencia optimista, que impactan en el diseño de servicios.

HTTP y REST
^^^^^^^^^^^

Como vemos el protocolo HTTP está diseñado para cumplir los principios REST. Tenemos recursos (documentos web), que poseen UUIDs (URIs) y que pueden ser accesibles mediante múltiples representaciones (tipos MIME). Además se tiene un conjunto de operaciones predefinidas, los verbos HTTP, que se pueden utilizar siguiendo petición/respuesta stateless de HTTP. Como se ve HTTP tiene todos los ingredientes de una arquitectura REST.

Sin embargo existen formas de usar el protocolo HTTP que no son REST, aunque se le parecen. A estos diseños los llamamos servicios RESTlike, en contraposición a los servicios REST puros o RESTful.

Un ejemplo típico de servicio RESTlike se produce cuando las distintas acciones tienen URI propia. Por ejemplo "http://www.server.com/reserva/123/completar" o también "http://www.server.com/reserva/123?action=completar". Esto rompe con el principio REST más simple, que es que se deben exponer sólo recursos y no operaciones. También rompe el principio REST que indica que sólo los recursos deben tener UUID y ser referenciables.

Otro tipo de servicios RESTlike son aquellos en los que se usa siempre el mismo verbo HTTP para todas las acciones, normalmente POST. En estos diseños se suele usar o bien la URI (como vimos antes), o bien algún parámetro en el cuerpo de la petición, para indicar que acción queremos. En el último caso realmente estamos rompiendo HTTP, ya que como vimos cada verbo tiene un significado distinto y toda la infraestructura de la web está preparado para ello.

Otra práctica que no es REST es tener distintas URIs para pedir el recurso en distintos formatos. Ejemplo: "http://www.server.com/reserva/22.html" y "http://www.server.com/reserva/22.pdf". El tipo de formato se debe indicar en las cabeceras HTTP "Content-Type" y "Accept". Según REST sólo los recursos pueden tener URI, y una misma URI se puede servir usando distintas representaciones.

Recordad que estos enfoques no son REST, no caigais en la tentación.

Buenas prácticas y patrones
---------------------------

El buen diseño de servicios web REST se basa en saber como mapear los distintos conceptos de REST al protocolo HTTP. La idea es aprovechar bien todas las capacidades de dicho protocolo para implementar REST sin destruir la semántica estándar de HTTP. De esta forma conseguiremos aprovechar de forma efectiva toda la infraestructura que ya está disponible en la web, como caches, proxies, firewalls y CDNs.

Cuando diseñemos nuestros servicios REST hay que pensar que la API de éstos consta de lo siguiente:

* El diseño de URIs que vayamos a seguir, y al menos la URI de un servicio raíz a partir del cual entrar en el sistema. El cliente sólo debería conocer esta URI raíz.
* Los tipos MIME soportados por los recursos REST.
* Los verbos HTTP soportados. No debemos romper la semántica de dichos métodos HTTP.

Cualquier cambio en alguno de estos puntos implica cambiar el API público de nuestro sistema, y por lo tanto romper la interoperabilidad con nuestros clientes.

En esta sección veremos las prácticas más importantes en este sentido, y cómo podemos aprovechar las capacidades de HTTP en nuestro favor.

CRUD
~~~~

El caso de uso más sencillo al diseñar servicios REST con HTTP se produce cuando dichos servicios publican operaciones CRUD(*) sobre entidades. En este tipo de diseños existen dos tipos de recursos: entidades y colecciones. 

Las colecciones actuan como listas o contenedores de entidades, y en el caso puramente CRUD se suelen corresponder con tablas de base de datos. Normalmente su URI se deriva del nombre de la entidad que contienen. Por ejemplo, "http://www.server.com/rest/libro" sería una buena URI para la colección de todos los libros dentro de un sistema. Para cada colección se suele usar el siguiente mapeo de métodos HTTP a operaciones:

[options="header"]
|=============================================================
|Método HTTP| Operación                                       
|    GET    | Leer todas las entidades dentro de la colección
|    PUT    | Actualización mútiple y/o masiva                
|   DELETE  | Borrar la colección y todas sus entidades       
|    POST   | Crear una nueva entidad dentro de la colección  
|=============================================================

Las entidades son ocurrencias o instancias concretas, que viven dentro de una colección. La URI de una entidad se suele modelar concatenado a la URI de la colección correspondiente un identificador de entidad. Este identificador sólo necesita ser único dentro de dicha colección. Ej. "http://www.server.com/rest/libro/ASV2-4fw-3" sería el libro cuyo identificador es "ASV2-4fw-3". Normalmente se suele usar la siguiente convención a la hora de mapear métodos HTTP a operaciones cuando se trabaja con entidades.

[options="header"]
|=====================================================================
|Método HTTP| Operación                                               
|    GET    | Leer los datos de una entidad en concreto               
|    PUT    | Actualizar una entidad existente o crearla si no existe 
|   DELETE  | Borrar una entidad en concreto                          
|    POST   | Añadir información a una entidad ya existente           
|=====================================================================

A continuación, en las siguientes secciones, veremos más en detalle opciones de diseño de cada operación CRUD.

(*) El acrónimo CRUD responde a "Create Read Update Delete" y se usa para referirse a operaciones e mantenimiento de datos, normalmente sobre tablas de un gestor relacional de base de datos.

Lectura de entidades
^^^^^^^^^^^^^^^^^^^^

La operación que parece más sencilla de modelar es la de lectura, aunque como veremos el demonio está en los detalles.

Todas las operaciones de lectura y consulta deben hacerse con el método GET, ya que según la especificación indica la operación de recuperar información del servidor.

El caso más sencillo es el de leer la información de una entidad, que se realiza haciendo un GET contra la URI de la entidad. Esto no tiene mucho más misterio, salvo en el caso de que el volumen de datos de la entidad sea muy alto. En estos casos es común que queramos recuperar los datos de la entidad pero sólo para consultar una parte de la información y no toda, con lo que estamos descargando mucha información que no nos es útil.

Una posible solución es dejar sólo en esa entidad los datos de uso más común, y el resto dividirlo en varios recursos hijos. De esta manera cuando el cliente lea la entidad, sólo recibirá los datos de uso más común y un conjunto de enlaces a los recursos hijos, que contienen los diferentes detalles asociados a ésta. Cada recurso puede ser o una entidad o una colección.

En general se suele seguir la convención de concatenar el nombre del detalle a la URI de la entidad padre para conseguir la URI de la entidad hija. Por ejemplo, dada una entidad http://www.server.com/rest/libro/23424-dsdff, si se le realiza un GET, recibiríamos un documento, con el título, los autores, un resumen, valoración global, una lista de enlaces a los distintos capítulos, otra para los comentarios y valoraciones, etc. Por ejemplo, para acceder al capítulo 3, podríamos modelar los capítulos como una colección y tener la siguiente URL: http://www.server.com/rest/libro/23424-dsdff/capitulo/3. Otra opción sería no tener esa colección intermedia y hacer que cada capítulo fuera un recurso que colgara directamente del libro, con lo que la URI sería: http://www.server.com/rest/libro/23424-dsdff/capitulo3. En el primer enfoque, tenemos a nuestra disposición una colección en http://www.server.com/rest/libro/23424-dsdff/capitulo, con la cual podemos operar de forma estándar, para insertar, actualizar, borrar o consultar capítulos. Sin embargo, si decidimos no tener esta colección intermedia, la creación de nuevos capítulos y su consulta debería hacerse mediante la entidad padre. La decisión depende sobre todo del uso que vayamos a dar a los recursos hijos. Si no lo tenemos claro, o si queremos mayor flexibilidad, es mejor optar por poner una colección intermedia. Si sólo vamos a acceder a los capítulos por nombre o número, quizás sea más sencillo eliminar esa colección intermedia.

Volviendo al problema de tener una entidad con un gran volumen de datos, existe otra solución en la que no es necesario descomponerla en varios recursos. Se trata simplemente de hacer un GET a la URI de la entidad pero añadiendo una querystring. Por ejemplo, si queremos ir al capítulo número 3, podemos hacer GET sobre http://www.server.com/rest/libro/23424-dsdff?capitulo=3. De esta forma hacemos una lectura parcial de la entidad, donde el servidor devuelve la entidad libro, pero con sólo el campo relativo al capítulo 3. A esta técnica la llamo "slicing". El usar "slicing" nos lleva a olvidarnos de esta separación tan fuerte entre entidad y colección, ya que un recurso sobre el que podemos hacer "slicing" es, en cierta medida, una entidad y una colección al mismo tiempo.

Como se aprecia REST es bastante flexible y nos ofrece diferentes alternativas de diseño, el usar una u otra depende sólo de lo que pensemos que será más interoperable en cada caso. Un criterio sencillo para decidir si hacer "slicing" o descomponer la entidad en recursos de detalle, es cuantos niveles de anidamiento vamos a tener. En el caso del libro, ¿se accederá a cada capítulo como un todo o por el contrario el cliente va a necesitar acceder a las secciones de cada capítulo de forma individual? En el primer caso el "slicing" parece un buen diseño, en el segundo no lo parece tanto. Si hacemos "slicing", para acceder a la sección 4 del capítulo 3, tendríamos que hacer: http://www.server.com/rest/libro/23424-dsdff?capitulo=3&seccion=4. Este esquema de URI es menos semántico, y además nos crea el problema de que puede confundir al cliente y pensar que puede hacer cosas como esta: http://www.server.com/rest/libro/23424-dsdff?seccion=4 ¿Qué devolvemos? ¿Una lista con todas las secciones 4 de todos los capítulos? ¿Un 404 no encontrado? Sin embargo en el diseño orientado a subrecursos es claro, un GET sobre http://www.server.com/rest/libro/23424-dsdff/capitulo/3/seccion/4 nos devuelve la sección 4 del capítulo 3, y sobre http://www.server.com/rest/libro/23424-dsdff/seccion/4 nos debería devolver 404 no encontrado, ya que un libro no tiene secciones por dentro, sino capítulos. Otra desventaja del "slicing" es que la URI no es limpia, y el posicionamiento en buscadores de nuestro recurso puede ser afectado negativamente por esto (sí, un recurso REST puede tener SEO, ya lo veremos más adelante).

A veces no tenemos claro cual va a ser el uso de nuestra API REST. En estos casos es mejor optar por el modelo más flexible de URIs, de forma que podamos evolucionar el sistema sin tener que romper el esquema de URIs, cosa que rompería a todos los clientes. En este caso el sistema más flexible es descomponer la entidad en recursos de detalle, usando colecciones intermedias si es necesario.

Recordad que se tome la decisión que se tome, esta no debe afectar al diseño interno del sistema. Por ejemplo, si decidimos no descomponer la entidad en recursos hijos, eso no significa que no pueda internamente descomponer una supuesta tabla de libros, en varias tablas siguiendo un esquema maestro detalle. Y viceversa, si decido descomper la entidad en varios subrecursos, podría decidir desnormalizar y tenerlo todo en una tabla, o quizás no usar tablas sino una base de datos documental. Estas decisiones de implementación interna, guiadas por el rendimiento y la mantenibilidad del sistema, deben ser invisibles al consumidor del servicio REST.

Consultas
^^^^^^^^^

La operación más común sobre una colección es la consulta. Si queremos obtener todos los miembros de una colección, simplemente hay que realizar un GET sobre la URI de la colección. En el ejemplo de los libros sería: http://www.server.com/rest/libro. Yo he puesto "libro" en singular, pero realmente es una colección. ¿Qué nos devolvería esta llamada? Realmente hay dos opciones: una lista con enlaces a todos los libros o una lista de libros, con todos sus datos.

La petición podría ser algo así:
---------------------------
GET /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------

Una respuesta, donde se devuelvan sólo enlaces:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

["http://www.server.com/rest/libro/45",
 "http://www.server.com/rest/libro/465",
 "http://www.server.com/rest/libro/4342"]
---------------------------

Un ejemplo del segundo sería:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

[ {
    "id": "http://www.server.com/rest/libro/45",
    "author": "Rober Jones",
    "title": "Living in Spain",
    "genre": "biographic",
    "price": { currency:"$", amount:33.2}
  },
  {
    "id": "http://www.server.com/rest/libro/465",
    "author": "Enrique Gómez",
    "title": "Desventuras de un informático en Paris",
    "genre": "scifi",
    "price": { currency:"€", amount:10}
  },
  {
    "id": "http://www.server.com/rest/libro/4342",
    "author": "Jane Doe",
    "title": "Anonymous",
    "genre": "scifi",
    "price": { currency:"$", amount:4}
  }]
---------------------------
Observen como vienen todos los datos del libro, pero además viene un campo extra "id", con la URI de cada libro.

¿Qué es mejor? En el primer diseño la respuesta ocupa menos espacio y ahorramos ancho de banda. En el segundo se usa mayor ancho de banda, pero evitamos tener que volver a llamar a las URIs cada vez que queramos traernos los datos de cada entidad, es decir ahorramos en llamadas de red y por lo tanto en latencia. En general sólo uso la primera cuando las entidades son muy grandes, pero como hemos visto en la sección anterior, podemos descomponer las entidades grandes en recursos hijos de detalle. Por lo tanto, el uso de la segunda alternativa para modelar la respuesta a una consulta es más eficiente si lo combinamos con la descomposición de entidades grandes en recursos hijos. Por esta razón, la técnica de "slicing" se usa menos frecuentemente que la otra.

Lo normal en todo caso, no es traerse todos los miembros de una colección, sino sólo los que cumplan unos criterios de búsqueda. La forma más sencilla es definir los criterios de búsqueda en la query string.

Petición para buscar libros de ciencia ficción con un precio máximo de 20euros
---------------------------
GET /rest/libro?precio_max=20eur&genero=scifi HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

[ {
    "id": "http://www.server.com/rest/libro/4342",
    "author": "Jane Doe",
    "title": "Anonymous",
    "genre": "scifi",
    "price": { currency:"€", amount:5}
  },
  {
    "id": "http://www.server.com/rest/libro/465",
    "author": "Enrique Gómez",
    "title": "Desventuras de un informático en Paris",
    "genre": "scifi",
    "price": { currency:"€", amount:10}
  }]
---------------------------

Nótese el detalle de que los resultados viene ordenados por precio. Normalmente el servidor debería ordenar los resultados de alguna manera en función de la consulta. Si quisiéramos que el cliente definiera en un orden diferente al que proporcionamos por defecto, deberíamos dar soporte a consultas como esta: http://www.server.com/rest/libro?precio_max=20&genero=scifi&ordenarPor=genero&ascendiente=false

¿Y si queremos buscar una entidad por identificador...? Simplemente hay que hacer un GET sobre la URI de la entidad, por lo que consultas por "clave primaria" no tienen sentido dentro de una colección REST.
Petición para un libro en particular:
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/465",
  "author": "Enrique Gómez",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:10}
}
---------------------------

Es muy común que una consulta devuelva demasiados datos. Para evitarlo podemos usar paginación. La forma más directa es añadir parámetros de paginación a la querystring. Por ejemplo:
---------------------------
GET /rest/libro?precio_max=40eur&genero=romance&ultimo_precio=12&ultimo_id=561f3&numero_resultados=10 HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Nótese el parámetro "numero_resultados", que indica al servidor cuantos resultados queremos como máximo. La paginación en si la hacemos usando los parámetros "ultimo_precio" y "ultimo_id", que indican cuál es el último resultado que se ha recibido. De esta forma el servidor debe realizar la consulta de forma que excluya dicho resultado y devuelva los siguientes 10 libros a partir de ése. Estamos jugando con la ordenación de los datos para conseguir la paginación. Existe otra variante para implementar la paginación y consiste en modelar directamente las páginas de resultados como recursos REST. Más adelante se hablará sobre ello.

Tal como se han diseñado las consultas anteriormente, el servidor tiene que estar preparado para interpretar correctamente los parámetros de la querystring. La ventaja es que es muy simple. La desventaja es que el cliente tiene que entender que parámetros hay disponibles y su significado, con lo que es menos interoperable. Existe otra forma de diseñar consultas, que consiste en modelarlas directamente como recursos REST. De esta forma podemos tener consultas que son recursos hijos de la colección principal. Se puede entender este enfoque como crear consultas predefinidas, filtros o vistas sobre la colección principal. En este enfoque podríamos hacer http://www.server.com/rest/libro/novedades y http://www.server.com/rest/libro/scifi para consultar las novedades y los libros de ciencia ficción respectivamente. Sobre estas colecciones hijas podemos añadir parámetros en la querystring para restringirlas más o para hacer paginación. Alternativamente podemos tener colecciones hijas anidadas hasta el nivel que necesitemos.

Esta forma de modelar consultas nos da una API mucho más limpia, y nos permite mayor interoperabilidad. Como mayor inconveniente está que es un enfoque menos flexible, ya que se necesita pensar por adelantado que consultas va a tener el sistema. Por lo tanto suele ser un diseño muy apropiado en aplicaciones de negocio donde normalmente sabemos las consultas que vamos a tener, pero no es muy apropiado en aplicaciones donde el usuario define sus propias consultas en tiempo de uso de la aplicación.

La tendencia de diseño es mezclar ambas opciones. Por un lado modelar explícitamente la consultas que se puedan detectar como colecciones hijas. Por otro lado permitir una consulta genérica, normalmente de texto libre, mediante querystring.

Actualizando
^^^^^^^^^^^^

A la hora de actualizar los datos en el servidor podemos usar dos métodos, PUT y POST. Según HTTP, PUT tiene una semántica de UPSERT, es decir, actualizar el contenido de un recurso, y si éste no existe crear un nuevo recurso con dicha información en la URI especificada. POST por el contrario puede usarse para cualquier operación que no sea ni segura ni idempotente, normalmente para añadir un trozo de información a un recurso o bien crear un nuevo recurso.

Si queremos actualizar una entidad lo más sencillo es realizar PUT sobre la URI de la entidad, e incluir en el cuerpo de la petición HTTP los nuevos datos. Por ejemplo:
---------------------------
PUT /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Y la respuesta es muy escueta:
---------------------------
HTTP/1.1 204 No Content

---------------------------
Esto tiene como consecuencia que el nuevo estado del recurso en el servidor es exactamente el mismo que el que mandamos en el cuerpo de la petición. La respuesta puede ser 204 o 200, en función de si el servidor decide enviarnos como respuesta el nuevo estado del recurso. Generalmente sólo se usa 204 ya que se supone que los datos en el servidor han quedado exactamente igual en el servidor que en el cliente. Con la respuesta 204 se pueden incluir otras cabeceras HTTP con metainformación, tales como "ETag" o "Expires". Sin embargo en algunos casos, en los que el recurso tenga propiedades de sólo lectura que deban ser recalculadas por el servidor, puede ser interesante devolver un 200 con el nuevo estado del recurso completo, incluyendo las propiedades de solo lectura.

Es decir, la semántica de PUT es una actualización donde reemplazamos por completo los datos del servidor con los que enviamos en la petición.

También podemos usar PUT para actualizar una colección ya existente. Veamos un ejemplo:
---------------------------
PUT /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 204 No Content

---------------------------
En este caso PUT ha sobreescrito los contenidos de la colección por completo, borrando los contenidos anteriores, e insertando los nuevos. Este tipo de uso de PUT no es algo que se recomiende ya que es bastante peligroso.

En los casos en los que queramos actualizar sólo algunos miembros de la colección y no otros podríamos usar una querystring para delimitar que miembros van a ser actualizados.
---------------------------
PUT /rest/libro?genero=scifi HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
La querystring define un subconjunto de recursos sobre la colección, a los cuales se les aplicará la operación PUT. De esta forma conseguimos una manera sencilla de hacer una actualización masiva. ¡ Pero esto haría que todos los libros de ciencia ficción tuvieran los mismos datos ! Realmente esto no es muy útil en este contexto. Pero sí lo es cuando estemos haciendo actualizaciones parciales, como veremos en otra sección.

En algunos casos la actualización no se puede llevar a cabo debido a que el estado del recurso lo impide, tal vez debido a alguna regla de negocio (por ejemplo, no se pueden devolver artículos pasados 3 meses desde la compra). En estos casos lo correcto es responder con un 409.
--------------------------
HTTP/1.1 409 Conflict

--------------------------

Borrando
^^^^^^^^

Para borrar una entidad o una colección, simplemente debemos hacer DELETE contra la URI del recurso.
---------------------------
DELETE /rest/libro/465 HTTP/1.1
Host: www.server.com

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 204 No Content

---------------------------
Normalmente basta con un 204, pero en algunos casos puede ser útil un 200 para devolver algún tipo de información adicional.

Hay que tener en cuenta que borrar una entidad, debe involucrar un borrado en cascada en todas las entidades hijas. De la misma forma, si borramos una colección se deben borrar todas las entidades que pertenezcan a ella.

Otro uso interesante es usar una querystring para hacer un borrado selectivo. Por ejemplo:
---------------------------
DELETE /rest/libro?genero=scifi HTTP/1.1
Host: www.server.com

---------------------------
Borraría todos los libros de ciencia ficción. Mediante este método podemos borrar sólo los miembros de la colección que cumplen la querystring.

Creando
^^^^^^^

Una forma de crear nuevos recursos es mediante PUT. Simplemente hacemos PUT a una URI que no existe, con los datos iniciales del recurso y el servidor creará dicho recurso en la URI especificada.
Por ejemplo, para crear un nuevo libro:
---------------------------
PUT /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Nótese que la petición es indistinguible de una actualización. El hecho de que se produzca una actualización o se cree un nuevo recurso depende únicamente de si dicho recurso, identificado por la URL, existe ya o no en el servidor. La respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.server.com/rest/libro/465
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/465"
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Nótese que el código de respuesta no es ni 200 ni 204, sino 201, indicando que el recurso se creó con éxito. Opcionalmente, como en el caso del ejemplo, se suele devolver el contenido completo del recurso recien creado. Es importante fijarse en la cabecera "Location" que indica, en este caso de forma redundante, la URL donde se ha creado el nuevo recurso.

Otro método para crear nuevos recursos usando POST. En este caso hacemos POST no sobre la URI del nuevo recurso, sino sobre la URI del recurso padre.
---------------------------
POST /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.server.com/rest/libro/3d7ef
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/3d7ef"
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
En este caso la cabecera "Location" no es superflua, ya que es el servidor quien decide la URL del nuevo recurso, no el cliente como en el caso de PUT. Además cuando creamos un nuevo recurso con POST, éste siempre queda subordinado al recurso padre. Esto no tendría porque ser así con PUT.

¿Qué es mejor? POST tiene como ventaja que la lógica de creación URIs no está en el cliente, sino bajo el control del servidor. Esto hace a nuestros servicios REST más interoperables, ya que el servidor y el cliente no se tienen que poner de acuerdo en que URIs son válidas y cuáles no, y en el algoritmo de generación de URIs. Por otro lado POST no es idempotente, mientra que PUT sí. Esto hace que PUT sea muy útil para poder recuperarnos de problemas de conectividad. Si el cliente tiene dudas sobre si su petición de creación se realizó o no, sólo tiene que repetirla. Sin embargo esto no es posible con POST, ya que duplicaríamos el recurso en el caso de que el servidor sí atendió a nuestra petición y nosotros no lo supiéramos.

¡ No uses CRUD !
^^^^^^^^^^^^^^^^

Hasta el momento he estado diseñando la API REST de una forma muy similar a como se diseñaría una BBDD. Algunos estarían tentados de ver las colecciones como "tablas" y las entidades como "filas", y pasar por alto el verdadero significado de lo que es un recurso REST. Este diseño ciertamente puede ser útil en casos sencillos, pero si queremos exprimir al máximo las capacidades de interoperabilidad del enfoque REST debemos ir más allá de esta forma de pensar. Más adelante veremos otras técnicas de diseño que maximizan la interoperabilidad.

Por otra parte, como se ha visto antes, no es bueno acoplar nuestro diseño de API REST a la implementación del sistema. En este sentido hay que tener cuidado con los frameworks. Por ejemplo, no es deseable el diseño de tu sistema REST se acople a tu diseño de tablas. En general el diseño de la API REST debe estar totalmente desacoplado de la implementación, y dejar que esta última pueda cambiar sin necesidad de alterar tu capa de servicios REST.

Servicios multimedia
~~~~~~~~~~~~~~~~~~~~

Una ventaja de los servicios REST es que permite negociar el formato exacto en el que se va a intercambiar la información.

Como ya vimos cada formato viene definido por un tipo MIME, y podemos usar las cabeceras Accept y Content-Type para gestionar qué tipo MIME se va a usar.

Esto nos abre un nuevo campo con el que hacer nuestros servicios más potentes. Usando la misma URI y los mismos métodos HTTP, podemos consumir el recurso en distintos formatos, no es necesario tener una URI diferente para cada formato.

Por ejemplo podríamos consumir el recurso http://www.server.com/rest/libro/3d-5FG-67 como JSON para poder mostrar información del libro dentro de nuestra aplicación web rica. Al mismo tiempo podemos usar el formato PDF para descargar una copia del libro cuando alguien lo compre. También podríamos consumirlo como audio y descargar la versión audiolibro del mismo. Otra opción sería pedir el recurso en formato HTML, y entonces recibo una página web con la que ver los detalles del libro y poder comprarlo. El límite realmente está en definir que es lo que tiene sentido desde un punto de vista de negocio.

Otro ejemplo sería un recurso colección con todos los movimientos bancarios de una cuenta. Lo puedo consumir como HTML y acceder a una página web donde visualizar y operar. ¿Y por qué no en forma Excel para descargarlos como una hoja de cálculo? ¿Y que tal en PDF para poder imprimir los recibos de todos los movimientos? ¿O quizás es mejor pedirlo en formato JPG o GIF para ver una bonita gráfica de gastos/ingresos?

En general, para maximizar la interoperabilidad, es mejor usar tipos MIME estandarizados, al fin y al cabo, de esta forma no tendremos que crear clientes específicos para consumir esos tipos MIME.

De forma opcional, se suelen definir tipos MIME específicos y propietarios para nuestros servicios REST. En estos casos, cuando el tipo MIME no es estándar, el nombre del tipo empieza por "x-". Estos tipos propietarios suelen estar muy optimizados para el caso concreto de nuestro sistemas. Por ejemplo, si quiero definir un formato especial para los datos de libro, podría publicar el recurso libro de forma que soportara el tipo "application/x-libro". De esta forma los clientes que soporten este tipo especial podrían aprovechar las características optimizadas de este tipo.

En cualquier caso, crear tipos MIME propietarios de nuestra aplicación es algo opcional, ya que implica menor interoperabilidad ya que los posibles consumidores del recurso no lo entenderán a priori, y necesitarán hacer un desarrollo a medida para consumir dicho formato. Por lo tanto, independientemente de tener tipos MIME propietarios, siempre debemos publicar los recursos REST mediante tipos MIME estándar.

Concurrencia optimista
~~~~~~~~~~~~~~~~~~~~~~

En sistemas distribuidos siempre debemos tener en cuenta los efectos de la concurrencia en la consistencia del estado del sistema. En el caso concreto de los servicios web, puede ocurrir que dos clientes lean el estado del mismo recurso y ambos manden modificaciones al servidor. Obviamente una modificación llegará al servidor antes que la otra. Esto causa que la modificación que llegue más tarde se base en datos obsoletos, lo que dependiendo del caso puede ser indeseable. En sistemas distribuidos de alta escalabilidad, como es el caso de los servicios web, la concurrencia pesimista no es apropiada, ya que evita la escalabilidad del sistema. Es mucho más apropiado un esquema de concurrencia optimista [7], donde no hay bloqueo de datos, y en caso de conflicto la petición de escritura es rechazada, y el cliente notificado de tal hecho de forma ordenada.

En servicios REST podemos implementar la concurrencia optimista mediante el uso de la cabecera HTTP ETag. Esta cabecera permite al servidor indicar en la respuesta una hash o fingerprint del estado del recurso. La idea es que la ETag cambie si y sólo si el estado del recurso cambia. Hay dos formas sencillas de implementar una ETag en el servidor: mediante una hash resistente a colisiones y mediante un identificador de versión.

Existen dos tipos de ETag, las fuertes y las débiles. Si el estado del recurso cambia en al menos un bit, una ETag fuerte también cambia de valor. Nos permiten hacer una hash o fingerprint a nivel binario. Las ETag fuertes también tienen en cuenta los valores de las cabeceras HTTP y el formato concreto del documento. Por lo tanto si añadiésemos un espacio a un documento JSON, una ETag fuerte cambiaría, aunque la semántica del JSON no haya cambiado. Para solucionar esto existen las ETag débiles. Las ETag débiles no deberían cambiar con la mínima alteración del contenido de un mensaje HTTP, sino sólo si la semántica del estado del recurso ha cambiado. Sintácticamente podemos distinguir a una ETag fuerte de una débil, ya que la débil debe tener concatenado "W/" como prefijo.Por ejemplo, una ETag fuerte sería: "sdl1kfj3FA", y una débil W/"sdl1kfj3FA".

Para hacer concurrencia optimista nos basta con ETag débiles. Como ya se dijo, podemos usar en el servidor una hash resistente a colisiones o un número de versión, que se actualizan cada vez que se modifiquen o cree un recurso. Es importante que el cálculo de la ETag sea consistente entre todas las máquinas servidoras en las que está distribuido nuestros servicios REST. Es decir, la ETag debería ser la misma independientemente de que servidor responda a la petición. El valor de la ETag así generado podría persistirse junto con el estado del recurso, para futura referencia.

¿Y qué tiene todo esto que ver con la concurrencia optimista? Es simple, podemos usar la ETag para detectar los conflictos, y hacer peticiones HTTP condicionales.

Supongamos que hemos recibido lo siguiente del servidor al hacer una petición GET:
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8
ETag: W/"686897696a7c876b7e"

{
  "id": "http://www.server.com/rest/libro/465",
  "author": "Enrique Gómez",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:10}
}
---------------------------

El cliente inspeccionando la ETag puede saber la "versión" de los datos y usarlo posteriormente en peticiones condicionales HTTP. Supongamos que el cliente desea realizar una actualización de la entidad recibida, y por lo tanto envía un PUT.
---------------------------
PUT /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
If-Match: W/"686897696a7c876b7e"
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
En este caso, hace el PUT condicional mediante la cabecera If-Match. En esta cabecera se incluye el valor del ETag que posee el cliente. El servidor antes de realizar ninguna operación compara el ETag que tiene del recurso con el ETag enviado por el cliente en la cabecera If-Match. Si ambas coinciden, realiza la operación, como es el caso del ejemplo anterior. Si los ETag no coincidieran, el servidor no realizaría la petición, e informaría al cliente.
El mensaje de respuesta, en caso de éxito sería:
---------------------------
HTTP/1.1 204 No Content
ETag: W/"9082aff9627ab7cb60"

---------------------------
Obsérvese que se devuelve la nueva ETag del recurso modificado. Sin embargo podría haber ocurrido que el recurso hubiera sido modificado antes de que se realice nuestra petición de modificación. Estaríamos ante un conflicto de versiones. En este caso la respuesta sería diferente:
---------------------------
HTTP/1.1 412 Precondition Failed

---------------------------
La respuesta 412 puede ir acompañada de más cabeceras HTTTP.

El uso de If-Match nos permite asegurarnos que la petición se va a procesar sólo si los datos no han cambiado desde que fueron recuperados por el servidor. Si algún otro cliente hubiera cambiado el estado del recurso antes de que llegara nuestra petición de modificación, las ETag no coincidirían y el servidor no ejecutaría la acción. Es importante que el cliente es notificado de tal circunstancia, ya que puede tomar acciones para reparar el problema. La acción más sencilla es volver a pedir los datos frescos al servidor y notificar al usuario. Otra opción más compleja es pedir los datos frescos y permitir al usuario fusionar sus cambios con los nuevos datos.

Actualizaciones parciales
~~~~~~~~~~~~~~~~~~~~~~~~~

La técnica de actualización explicada anteriormente nos sirve sólo si queremos actualizar por completo un recurso, pero no es válida si necesitamos actualizar sólo unos campos y otros no.

Si lo que queremos hacer realmente es una actualización parcial, la mejor práctica en este caso es revisar el modelo de nuestros recursos. Normalmente cuando surge esta necesidad, es porque queremos operar con trozos más pequeños del recurso original. En estos casos es mejor dividir el recurso principal, y crear recursos detalle con sus propias URI. El recurso principal contendrá sólo la información más esencial y enlaces a todos los recursos que contienen información más detallada o secundaria. De esta forma cada recurso detalle tiene su propia URI y puede ser actualizado de forma independiente. 

Sin embargo, pueden existir algunos casos de uso donde este enfoque no sea práctico. Supongamos que por motivos de rendimiento queremos intercambiar entre el cliente y el servidor únicamente los cambios que se produzcan en el recurso, y ahorrar así ancho de banda.

En estos casos estaríamos tentados de usar PUT para mandar sólo esos cambios, algo como lo que sigue:
---------------------------
PUT /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
If-Match: W/"686897696a7c876b7e"
Content-Type: application/json

{
  "price": { currency:"€", amount:100},
  "author": [ "Enrique Gómez Salas", "Juan Pérez" ]
}
---------------------------
Como vemos en este ejemplo, sólo enviamos un documento parcial, con sólo los campos a actualizar. El servidor interpretaría que los campos que no se encuentren en la petición debe dejarlos intacto. Esta forma de usar PUT no es REST, ya que la especificación HTTP dice que el contenido del cuerpo de la petición pasa a ser el nuevo estado del recurso, es decir, el estado del recurso se debe sobreescribir por completo con lo que viene en la petición. Por lo tanto debemos buscar otra alternativa.

Esa alternativa sería POST. Normalmente se interpreta que POST va a añadir contenido por el final cuando se usa para actualizar, pero la especificación sólo nos indica que esa es una de las posibles acciones que se pueden admitir. El método POST sobre una URI se puede interpretar según el estándar de otras formas. En el caso que nos ocupa se puede usar la interpretación de "añadir" en vez de crear un recurso subordinado. La idea es que podemos ir "añadiendo" información al recurso poco a poco. El truco para hacer una actualización parcial es usar un tipo MIME que representa un cambio de estado, o "diff", que se "añade" al estado del servidor. Si mandamos varios de estos "diff" al servidor, éste los va "sumando" y el recurso se va actualizando incrementalmente.
--------------------------
POST /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/book-diff+json

[{
    "change-type":"replace",
    "location":"price/amount",
    "value":100
 },
 {
   "change-type":"append",
   "location":"author",
   "value":"Juan Pérez"
 }]
--------------------------
Sin embargo hay que tener cuidado, POST al contrario que PUT no es idempotente, ¿qué debería hacer el servidor si vuelvo a repetir la petición pensando que no se ejecutó correctamente en el servidor? Una implementación poco sofisticada del servidor podría volver a aplicar los cambios:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/465",
  "author": [ "Enrique Gómez Salas", "Juan Pérez", "Juan Pérez" ],
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:100}
}
---------------------------
En este caso hemos enviado el mismo "diff" de forma duplicada. Esto hace que la segunda petición sea inconsistente, ya que al haberse procesado el primer "diff" (sin que el cliente lo supiera), el segundo no tiene sentido. En estos casos el servidor debería fallar, con un 409, y no duplicar la petición.
--------------------------
HTTP/1.1 409 Conflict

--------------------------
Se falla con 409 para indicar que existe un conflicto entre la petición y el estado del recurso. Sin embargo, no se especifica en qué consiste este conflicto, ya que 409 es un código de error bastante genérico. Otro problema es que a veces el servidor no podría detectar que la petición es duplicada inspeccionando sólo el cuerpo de esta. En este caso es sencillo, ya que el autor está duplicado, pero en otros casos la cosa no sería tan sencilla.

Debido a estos problemas es mejor usar peticiones condicionales mediante ETag e If-Match cuando hagamos actualizaciones parciales. Por un lado es más explícito y por otro el servidor puede detectar las peticiones duplicadas de forma más sencilla.
--------------------------
POST /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
If-Match: W/"686897696a7c876b7e"
Content-Type: application/book-diff+json

[{
    "change-type":"replace",
    "location":"price/amount",
    "value":100
 },
 {
   "change-type":"append",
   "location":"author",
   "value":"Juan Pérez"
 }]
--------------------------
Y si existe una duplicación o un problema de carrera el servidor responde con:
---------------------------
HTTP/1.1 412 Precondition Failed

---------------------------
Que es mucho más explícito, sencillo de implementar y de depurar.

Otro punto importante a la hora de hacer actualizaciones parciales es usar un tipo MIME que represente explícitamente un "diff". Si no nuestra API sería confusa. Ya existen tipos MIME en proceso de estandarización para representar "diff" entre documentos. Algunos están basados en XPath[13], y otros en formato JSON[14].

Método PATCH
^^^^^^^^^^^^

El problema del sistema anteriormente descrito para realizar actualizaciones parciales es que POST es un método genérico que admite casi cualquier tipo de operación que no sea ni segura ni idempotente. En este sentido se está convirtiendo en una especie de cajón de sastre donde podemos modelar casi cualquier operación que no encaje en el resto del marco de REST. Esto es un problema y puede llegar a hacer que los consumidores de nuestros recursos se confundan al usar POST.

Para solucionar este problema se ha propuesto añadir un nuevo método, el método PATCH, que todavía se encuentra en proceso de estandarización[12]. Al igual que POST es un método no seguro y no idempotente, pero tiene una semántica explícita de actualización parcial y sólo admite tipos MIME que representen "diffs". Al ser más explícito la API es más clara.

Todo lo explicado anteriormente sobre actualizaciones parciales se aplica a PATCH. Así el ejemplo anterior quedaría:
--------------------------
PATCH /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
If-Match: W/"686897696a7c876b7e"
Content-Type: application/book-diff+json

[{
    "change-type":"replace",
    "location":"price/amount",
    "value":100
 },
 {
   "change-type":"append",
   "location":"author",
   "value":"Juan Pérez"
 }]
--------------------------
Es exactamente igual que POST pero usando PATCH que es mucho más explícito y deja menos a la interpretación.

Una forma de saber si un recurso admite el método PATCH es hacer una petición con el método OPTIONS:
--------------------------
OPTIONS /rest/libro/465 HTTP/1.1
Host: www.server.com

--------------------------
Y la respuesta:
--------------------------
HTTP/1.1 200 OK
Allow: GET, PUT, POST, OPTIONS, HEAD, DELETE, PATCH
Accept-Patch: application/book-diff+json
Accept: application/json
Content-Length: 0

--------------------------
La respuesta indica los métodos aceptables por el recurso. En el caso de que se soporte PATCH, se debe incluir la cabecera "Accept-Patch" que indica que formatos mime se pueden usar con el método PATCH.

Sin embargo al ser un método nuevo que todavía no está estandarizado podemos tener problemas de interoperabilidad. Puede ser que el servidor no lo implemente, o que algún firewall bloquee dicho método. Para evitar esto podemos usar la cabecera "X-HTTP-Method-Override". Esta cabecera es ignorada por los nodos y servidores antiguos, pero permite indicar a los servidores más modernos que queremos usar un método diferente del especificado en la petición HTTP. Así, el ejemplo anterior quedaría como:
--------------------------
POST /rest/libro/465 HTTP/1.1
Host: www.server.com
X-HTTP-Method-Override: PATCH
Accept: application/json
If-Match: W/"686897696a7c876b7e"
Content-Type: application/book-diff+json

[{
    "change-type":"replace",
    "location":"price/amount",
    "value":100
 },
 {
   "change-type":"append",
   "location":"author",
   "value":"Juan Pérez"
 }]
--------------------------
Como se observa, para cualquier servidor o nodo que no entienda PATCH, la petición sería un POST. Pero en los casos en los que el servidor sí entienda PATCH, ignorará POST.

Actualmente PATCH está soportado por las APIs públicas de grandes compañías como Google o GitHub.

Cache
~~~~~

Es importante saber cuándo un cliente, nodo intermedio, o un CDN, puede cachear la respuesta de una petición GET y cuando no. Al cachear la respuesta podemos evitar llamadas al servidor, por lo que aumentamos la escalabilidad de éste. Esto es clave si queremos diseñar APIs REST que tengan una alta escalabilidad. Sin embargo debemos ser capaces de especificar cuándo hay que descartar el contenido cacheado de un recurso, de otra manera el cliente no se enteraría de los cambios.

Una forma de controlar la cache es mediante ETag. La cache puede hacer un GET condicional al servidor mediante la cabecera If-None-Match. De esta forma el servidor puede responder con la nueva información (y la nueva ETag) en el caso de que ésta haya cambiado.
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
If-None-Match: W/"686897696a7c876b7e"
Content-Type: application/json

---------------------------
El recurso sólo será devuelto por el servidor en el caso de que se haya producido algún cambio y el valor de la ETag haya cambiado. Por ejemplo:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8
ETag: W/"9082aff9627ab7cb60"
Last-Modified: Wed, 01 Sep 2012 13:24:52 GMT
Date: Tue, 27 Dec 2012 05:25:19 GMT
Expires: Tue, 27 Dec 2012 11:25:19 GMT
Cache-Control: max-age=21600

{
  "id": "http://www.server.com/rest/libro/465",
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
En el caso de que el recurso no haya cambiado el servidor respondería lo siguiente.
--------------------------
HTTP/1.1 304 Not Modified
Date: Tue, 27 Dec 2012 05:25:19 GMT
Expires: Tue, 27 Dec 2012 11:25:19 GMT
ETag: W/"686897696a7c876b7e"
Cache-Control: max-age=21600

--------------------------
El código 304 indica que el recurso que se pide no ha cambiado y realmente el contenido es el mismo. Con la respuesta se pueden enviar más cabeceras HTTP. De esta manera la cache se asegura que el recurso no ha cambiado, y ahorramos ancho de banda y procesamiento en servidor.

Otro método para gestionar la caché es usar las cabeceras If-Modified-Since y Last-Modified. En este caso no se mira ETag, sino sólo la última fecha de modificación del recurso que tenga el servidor (aunque la nueva versión del recurso se semánticamente equivalente a la que tiene el cliente).
La petición tendría la siguiente forma:
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
If-Modified-Since: Wed, 01 Sep 2012 13:24:52 GMT
Content-Type: application/json

---------------------------
En el caso que se hubiera producido una modificación posterior a la fecha especificada la respuesta sería:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8
Date: Tue, 27 Dec 2012 05:25:19 GMT
Expires: Tue, 27 Dec 2012 11:25:19 GMT
Cache-Control: max-age=21600
Last-Modified: Tue, 27 Dec 2012 03:25:19 GMT

{
  "id": "http://www.server.com/rest/libro/465",
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Si por el contrario los datos siguieran siendo los mismos:
TODO: Ejemplo Last-Modified, con cambios
--------------------------
HTTP/1.1 304 Not Modified
Date: Tue, 27 Dec 2012 05:25:19 GMT
Expires: Tue, 27 Dec 2012 11:25:19 GMT
ETag: W/"686897696a7c876b7e"
Cache-Control: max-age=21600

--------------------------
Observese que se devuelve el nuevo valor de Last-Modified.

Es importante tener en cuenta que la interpretación de la fecha se hace con respecto al reloj del servidor, pudiendo producirse problemas si el cliente y el servidor tienen los relojes muy desincronizados.

Es un esquema totalmente equivalente al de ETag e If-None-Match, pero usando la fecha de modificación en vez de la ETag. En ambos casos sacamos partido de la capacidad de hacer un GET condicional usando las cabeceras If-*.

Algunos os preguntareis por qué no usar Last-Modified en vez de ETag. Al fin y al cabo parece más simple de calcular en servidor. La razón es que algunas caches, notoriamente la cache de IE, no soportan correctamente If-Modified-Since, pero sí lo hacen bien con If-None-Match. Por otra parte algunos servidores de cache antiguos no soportan ETag. Por lo tanto se aconseja mezclar ETag y Last-Modified para un óptimo control de cache.

Sin embargo estos enfoques no impiden que la cache tenga que hacer una llamada a servidor y esperar la respuesta. Por muy sencillo que sea el procesamiento en servidor, y por muy poca información que transporte la petición y la respuesta, seguimos teniendo la penalización de la latencia, que en algunos casos, como en las redes móviles, suele ser alta. Podemos mejorar esto, y evitar peticiones GET condicionales innecesarias al servidor, si tenemos alguna idea de la frecuencia de cambio de los datos. Por ejemplo, en un servicio REST que sirva noticias para un periódico, podemos aguantar sin problemas aunque tengamos datos obsoletos de hace cinco minutos. Por lo tanto podríamos configurar la cache para que al menos aguante cinco, y no intente refrescar los datos en ese intervalo de tiempo. Esto se puede conseguir con el uso de Cache-Control y Expires. Se usa la cabecera Expires por compatibilidad con HTTP 1.0, y en caso de que ambas se contradigan Cache-Control tiene prioridad. Este es el motivo por el que en las respuestas de los anteriores ejemplos se incluyen estas cabeceras. Si pedimos los datos a un nodo de cache, y no se ha cumplido el plazo especificado mediante Cache-Control y/o Expires, la cache nos devolverá lo que tenga cacheado, y no se molestará en emitir una petición GET condicional al servidor. Sólo cuando este tiempo expire, la cache volverá a intentar comprobar si los datos han cambiado o no, normalmente usando tanto If-Match como If-Modified-Since.

Como se ve, el uso combinado de GET condicionales con las cabeceras de control de cache basada en tiempos, nos permiten un control fino de la cache. De esta forma podemos aprovechar la infraestructura de cache de nuestra red, e incluso de internet, pero a la vez asegurarnos que el cliente de nuestro servicio REST no se quede con datos obsoletos y vea los cambios.

URIs desechables y recursos "virtuales"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Anteriormente se ha comentado que es deseable siempre usar métodos HTTP idempotentes, ya que nos permiten una recuperación más simple de los posibles cortes y congestiones de la red.

El único método HTTP que no es idempotente es POST, ¿existirá alguna forma de prescindir de él? ¿O quizás se puede usar POST de alguna manera que no sea tan peligroso? Son preguntas importantes ya que POST es la manera más simple de crear un recurso, y de modelar operaciones genéricas.

La versión idempotente de POST podría ser PUT, pero tiene como problema que el consumidor del recurso REST necesita poder definir las URIs de los nuevos recursos y acciones. Como vimos anteriormente esto podría disminuir la interoperabilidad, ya que el algoritmo de generación de URIs tendría que estar implementado en el cliente y ser consistente con el servidor. Por la misma razón esto puede generar problemas de seguridad.

La forma de solucionar esto es haciendo trabajar juntos a PUT y a POST. En este diseño el cliente cuando quiere crear un nuevo recurso, o quizás ejecutar un comando arbitrario, le pide permiso al servidor mediante una llamada POST. El servidor puede rechazar la llamada o bien concederle permiso. Si le concede permiso, el servidor genera una nueva URI que es devuelta al cliente. Esta URI representa un nuevo recurso que está vacio, y por lo tanto el servidor no necesita ni persistir ni almacenar en memoria. Se trata pues de un recurso "virtual" que no ocupa espacio en servidor. De esta forma si el cliente piensa que la petición se ha perdido, puede repetir la petición. Lo peor que podría pasar es que se creara una nueva URI para un nuevo recurso, pero como este recurso no ocupa recursos en servidor no pasa nada. El cliente puede después usar dicha URI para actualizar el recurso vacío mediante PUT. Es en ese momento cuando el servidor asigna memoria y realiza persistencia, y cuando se crea realmente el recurso de forma física. Si el cliente piensa que esta última petición falló, puede repetir la petición sin problemas, ya que PUT es idempotente.

Resumiendo:

1. El cliente hace POST a un recurso "factoría", encargado de crear recursos "virtuales".
2. El servidor devuelve la URI de ese nuevo recurso "virtual"
3. El cliente hace PUT a la URI devuelta con los datos que el considera debe tener el recurso
4. El servidor actualiza el recurso con los datos transmitidos en el PUT, y lo persiste.

Como se aprecia el truco consiste en que el recurso no se crea realmente hasta que no se recibe el PUT. Sin embargo queda un problema por resolver: si no almacenamos nada ni en memoria ni en soporte persistente, ¿cómo puede el servidor saber que la URI que le llega en el PUT es legítima? Al fin y al cabo no queremos que el cliente genere las URIs, sino que el servidor controle tal cosa. Lo ideal sería que si el cliente nos manda un PUT a una URI que no existe devolvamos un código 403, indicando que el cliente no tiene permiso para generar recursos en URIs que no sean asignadas por el servidor.

Una solución inocente sería almacenar en algún sitio, en memoria tal vez, las URIs de los recursos, y chequear contra esta información la URI de la petición PUT. Sin embargo esto contradice el principio de que los recursos "virtuales" no deben ocupar espacio en servidor. De lo contrario el cliente no podría reintentar el POST con la seguridad de que no va a pasar nada malo.

La solución consiste en generar una URI desechable. Las URIs desechables pueden ser reconocidas como legítimas por el servidor a simple vista, y no pueden ser falsificadas por el cliente. De esta forma no se se necesita almacenar la URI ni en memoria ni en soporte persistente. ¿Cómo generar una URI desechable? La forma más simple es tener en el servidor una clave secreta y un generador de UUID. La idea sería que cada vez que el servidor reciba un POST, genere un nuevo UUID, le concatene la clave secreta y el resultado lo pase por una función hash criptográfica. El resultado de este proceso es una firma de la URI. Esta firma es concatenada con el UUID anteriormente generado. Esto termina generando un identificador que se transforma en el último segmento de la ruta de la URI.

  FIRMA = HASH(UUID+SECRETO)
  URI = URI_RECURSO_PADRE + "/" + UUID + "_" + FIRMA

Cuando el servidor reciba un PUT, es tan sencillo como extraer el UUID del último segmento de la ruta de la URI, calcularle la firma, y ver si coinciden. Si es así la URI es legítima, si no, debemos devolver 403. Esta lógica puede hacerse genérica a todas las peticiones PUT e implementarse en un filtro común a todas las URIs.

Veamos un par de ejemplos de uso de esta técnica.

Crear recursos
^^^^^^^^^^^^^^

Primero el cliente hace un POST al recurso colección, sin datos:
---------------------------
POST /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.server.com/rest/libro/65557e01989246c59826a1a0ad1d5c7a_45be291cd8e154b258f2c22538bccc34

---------------------------
El cliente, usando la URI que le ha sido devuelta en la cabecera location, realiza un PUT con los datos de la nueva entidad.
---------------------------
PUT /rest/libro/65557e01989246c59826a1a0ad1d5c7a_45be291cd8e154b258f2c22538bccc34 HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Con esta petición el "recurso virtual" representado por la URI se transforma en un recurso con los datos especificados en la petición PUT. La respuesta:
---------------------------
HTTP/1.1 200 OK
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/65557e01989246c59826a1a0ad1d5c7a_45be291cd8e154b258f2c22538bccc34"
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
De esta forma podemos crear un recurso en dos fases. Primero solicitar la URI, y después confirmar mediante un PUT. De esta forma podemos repetir todas las veces que queramos la petición POST porque generar URIs de "recursos virtuales" no consumen apenas recursos, y por supuesto podemos repetir la petición PUT para transformar el "recurso virtual" en uno real, ya que PUT es idempotente.

Comando
^^^^^^^

Una forma de modelar operaciones de negocio genéricas es transformar las operaciones en recursos. Por ejemplo, si queremos comprar un libro, en vez de tener una URI https://www.server.com/rest/comprar, la URI debería ser https://www.server.com/rest/compra. Nótese la diferencia entre el verbo y el nombre.

¿Como haríamos una compra? Primero haríamos un POST al recurso "compra" para que nos asignase un identificador de nueva compra en forma de URI:
---------------------------
POST /rest/compra HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.server.com/rest/compra/3b99535d52fd4d84901b028511750247_b80d4b5a5a62546a08853dab8024633f

---------------------------

Después podemos confirmar la compra mediante un PUT a dicha URI, indicando los datos de compra en el cuerpo del PUT.
---------------------------
PUT /rest/compra/3b99535d52fd4d84901b028511750247_b80d4b5a5a62546a08853dab8024633f HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "payment-method":"visa",
  "cardnumber": 1234567812345678,
  "secnumber":333,
  "expiration": "08/2016",
  "cardholder": "Pepe Pérez",
  "order": "http://www.server.com/rest/orders/345",
  "status": "created"
}
---------------------------

Lo interesante es que podríamos consultar el estado de la compra haciendo un GET a dicha URI.
---------------------------
GET /rest/compra/3b99535d52fd4d84901b028511750247_b80d4b5a5a62546a08853dab8024633f HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta indicando que la compra está en fase de aprobación:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json

{
  "payment-method":"visa",
  "cardnumber": 1234567812345678,
  "secnumber":333,
  "expiration": "08/2016",
  "cardholder": "Pepe Pérez",
  "order": "http://www.server.com/rest/orders/345",
  "status": "verifying"
}
---------------------------

También podríamos solicitar la anulación de la compra haciendo un nuevo PUT:
---------------------------
PUT /rest/compra/3b99535d52fd4d84901b028511750247_b80d4b5a5a62546a08853dab8024633f HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "payment-method":"visa",
  "cardnumber": 1234567812345678,
  "secnumber":333,
  "expiration": "08/2016",
  "cardholder": "Pepe Pérez",
  "order": "http://www.server.com/rest/orders/345",
  "status": "canceled"
}
---------------------------
El si se puede o no cancelar la compra y que implica eso depende de la lógica de negocio. Otra forma de cancelar la compra sería usar una actualización parcial del campo "status", ya sea usando PATCH o POST. En cualquier caso si la compra ya no se pudiera cancelar o modificar alguno de sus detalles, se debería devolver 409 (Conflict).

No es el caso de la "compra", pero a veces la operación se puede deshacer por completo sin ningún problema. Si se puede hacer esto o no depende del dominio de negocio. En estos casos lo más simple sería usar DELETE para borrar el comando.

Como vemos el patrón comando, implementado con una combinación de PUT y POST, nos da una gran flexibilidad no sólo a la hora de implementar operaciones arbitrarias, sino también procesos de negocio.

Versionado de API
~~~~~~~~~~~~~~~~~

Como en cualquier sistema de servicios web, cuando usamos REST estamos publicando una API. Si cambiamos esa API entonces vamos a romper la interoperabilidad con los clientes antiguos. ¿Cómo podemos cambiar la API de forma que tenga el mínimo impacto posible?

Uno de las posibles cosas que pueden cambiar es el formato. Es muy común que se añadan nuevos campos para reflejar nueva información, o que empecemos a soportar nuevos tipos MIME. Realmente esto no suele ser un problema, basta con que el cliente ignore los campos que no entienda o no pueda procesar. Si usamos XML hay que tener a la hora de definir el XML Schema, y dejar puntos de extensión dentro de éste.

Si por cualquier razón hacemos un cambio en el formato de datos que vaya a romper los clientes de forma inevitable, podemos aprovechar la capacidad multimedia de HTTP en nuestro provecho. Podemos publicar el nuevo formato con otro nombre, y seguir soportando el antiguo. El formato antiguo lo podemos marcar como obsoleto en la documentación, pero seguir sirviéndolo mientras los clientes que lo consuman no sean una ínfima minoría. Por ejemplo, si soportábamos "application/x-libro+xml", y hacemos un cambio que inevitablemente no pueda ser retrocompatible, haremos este cambio en otro tipo MIME "application/x-libroV2+xml" y dejaremos el original tal como estaba. De esta forma los clientes antiguos pueden seguir consumiendo el formato antiguo, y los nuevos aprovechar las ventajas del nuevo tipo MIME.

Otra cosa que puede cambiar es la URI. Realmente esto hay que evitarlo a toda costa, pero si se da el caso tiene fácil solución. Sólo hay que configurar una nueva redirección permanente a la nueva URI y asunto resuelto.

Multiidioma
~~~~~~~~~~~

Mediante el protocolo HTTP podemos construir un soporte multiidioma robusto en nuestros servicios REST.

Mediante la cabecera Accept-Charset el cliente puede especificar al servidor los juegos de caracteres que soporta por orden de preferencia. Podemos especificar una lista de juegos de caracteres, e incluso especificar preferencia mediante el parámetro q. Se trata de un mecanismo similar al usado en la cabecera Accept para especificar preferencia en tipos MIME. Si no se define el juego de caracteres se escogerá ISO-8859-1 por defecto.

Lo mismo podemos hacer con la cabecera Accept-Language, definir una lista por orden de preferencia de los lenguajes que desea el usuario. El servidor debe incluir en la respuesta la cabecera Content-Language indicando el idioma escogido.

Ejemplos:
--------------------------
Accept-Charset: iso-8859-5, unicode-1-1;q=0.8
Accept-Language: da, en-gb;q=0.8, en;q=0.7
--------------------------

Seguridad
~~~~~~~~~

Como en todo sistema de servicios web, debemos preocuparnos por la seguridad. Éste es un campo muy complejo, pero podemos cumplir algunas normas básicas de seguridad sin gran esfuerzo, y evitar un gran número de ataques.

Cuidado con los identificadores
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Lo primero que hay que tener en cuenta es no usar identificadores predecibles, como los autoincrementados. Esto puede permitir a un posible atacante ir averiguando identificadores válidos de recursos que despues pueden ser usados en otro ataque.

Si usamos las "URIs desechables" que explicamos anteriormente se resuelve este problema, ya que ni los UUIDs ni la firma son predecibles por posibles atacantes.

Otro posible riesgo consiste en usar las claves primarias de nuestro sistema de persistencia para montar las URIs. Esto nos puede exponer a otros ataques como la inyección de SQL o de código.

Una posible solución es tener en formato persistente un mapeo entre las URIs y las verdaderas claves primarias. Otra solución más eficiente puede ser construir la clave primaria a partir de la URI mediante una clave secreta. Se trataría de hacer una hash criptográfica de la URI con un secreto.

  PK = HASH(URI+SECRETO)

Podemos reforzar este método teniendo un secreto distinto por "rango" de URIs, o quizás por colección.

Privacidad
^^^^^^^^^^

La privacidad es otro aspecto a tener en cuenta. En recursos REST sensibles los datos no deberían transmitirse en claro por la red. La forma más obvia de solucionar esto es mediante el uso de HTTPS.

Si queremos un mayor nivel de seguridad, o incluso prescindir de HTTPS, podemos añadir una capa de encriptación a nivel de aplicación, de forma que la petición HTTP no esté encriptada, sino sólo su cuerpo. Esto sin embargo tiene como problema que disminuye la interoperabilidad al usar un sistema de encriptación no estándar.

Autenticación y autorización
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

El primer paso a implementar es un esquema de autenticación. Para ello HTTP nos proporciona un mecanismos desafío/respuesta mediante la cabecera WWW-Authenticate.

La idea es que cuando se realiza una petición a un recurso REST protegido, y la petición no lleva credenciales adecuadas, el servidor responde con un 401 que contiene una cabecera WWW-Authenticate. En dicha cabecera se detalla el tipo de credenciales que se necesita y el dominio de seguridad.
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
El servidor respondería:
---------------------------
HTTP/1.1 401 Authorization Required
WWW-Authenticate: Basic realm="catalog"

---------------------------
En este caso el servidor indica que se necesitan las credenciales para el área de seguridad "catalog", credenciales que han de corresponder al protocolo "Basic"[8]. El cliente debe responder al desafío repitiendo la petición pero esta vez indicando en la cabecera Authorization las credenciales pertinentes:
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
Authorization: Basic Y29udHJhc2XxYTpzZWNyZXRh

---------------------------
Si el servidor considera que las credenciales son suficientes, permite el acceso al recurso. Si por el contrario considera que el cliente, aunque posee credenciales válidas, no posee permisos suficientes para acceder al recurso, devuelve un 403.
---------------------------
HTTP/1.1 403 Forbidden
Content-Type: application/json

{"reason":"Not enough security level"}
---------------------------
Puede ocurrir que el servidor dictamine que la credenciales no identifican a un usuario del sistema. En ese caso debe devolver un 401 con un nuevo WWW-Authenticate.

En la especificación [8] se definen al menos dos algoritmos de authenticación. El primero es el llamado "Basic", y las credenciales de éste son simplemente la codificación en base 64 de la concatenación del usuario y password separados por ":". Al mandarse el usuario y contraseña en claro, nos vemos forzados a usar HTTPS si queremos tener algo de seguridad.

El otro algoritmo, "Digest", es más seguro y usa unas credenciales que no contienen la password en claro, como es el caso de "Basic". Esto permite autenticarse con seguridad sobre HTTP, sin necesidad de usar HTTPS. Detalles en [8].

¿Necesito una sesión HTTP?
^^^^^^^^^^^^^^^^^^^^^^^^^^

Es importante enfatizar que el protocolo HTTP no tiene sesión. La mal llamada sesión HTTP no es más que un truco implementado por los servidores de aplicaciones, donde se reserva un espacio de memoria en que puede ser referenciado mediante un identificador. Este identificador se pasa una y otra vez entre el servidor y el cliente, ya sea mediante una cabecera, ya sea dentro de la URI o mediante cookies.

Desde el punto de vista de servicios web REST esto no tiene mucho sentido, ya que los servicios son stateless y no hay que almacenar en ningún sitio la historia de la conversación entre cliente y servidor. 

Quizás algún lector estuviera tentado de usar esta pseudosesión HTTP como una forma de no tener que mandar una y otra vez el token de autenticación y simplificar la programación. Sin embargo el autor desaconseja dicha práctica por varias razones:

* Es una práctica no estándar desde el punto de vista de HTTP y la web.
* Es poco escalable, ya que impone al servidor una sobrecarga, al tener que reservar memoria para la sesión.
* Abre la posibilidad a implementar servicios web stateful, con memoria. Este tipo de servicios, a parte de no ser tan escalables, imponen un mayor acoplamiento entre cliente y servidor disminuyendo la interoperabilidad. Los servicios stateless son más sencillos al declarar explícitamente toda la información necesaria para consumirlos en forma de parámetros y no necesitar publicar un modelo de cómo cambia la respuesta del servicio en función del estado de la conversación.
* No se gana nada en rendimiento, ya que si antes tenemos que estar mandando continuamente el token de seguridad, usando sesión deberíamos mantar continuamente el identificador de sesión.

Por lo tanto el uso de sesión HTTP en servidor es una mala práctica desde el punto de vista de los servicios REST.

Peticiones asíncronas o de larga duración
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Algunas operaciones pueden representar acciones de larga duración o que desencadenen un workflow. En estos casos puede ser interesante no responder con 201 o 200 a una petición, sino con 202 'Accepted'. Este código indica que la operación ha sido aceptada por el servidor pero que tardará un tiempo en realizarse, y es ideal para modelar peticiones asíncronas. Normalmente en la respuesta se incluye una referencia a una URI que nos indicará el progreso de la operación, y que podremos consultar cada cierto tiempo.
Supongamos el ejemplo anterior sobre el pago:
---------------------------
PUT /rest/compra/3b99535d52fd4d84901b028511750247_b80d4b5a5a62546a08853dab8024633f HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "payment-method":"visa",
  "cardnumber": 1234567812345678,
  "secnumber":333,
  "expiration": "08/2016",
  "cardholder": "Pepe Pérez",
  "order": "http://www.server.com/rest/orders/345",
  "status": "created"
}
---------------------------
Si la pasarela de pago va a tardar o simplemente se debe producir un workflow interno de aprobación manual, la petición no se puede dar por terminada, asi que lo mejor es avisar al cliente que estamos trabajando en ella:
---------------------------
HTTP/1.1 202 Accepted
Content-Type: application/json

{"status":"verifying"}
---------------------------
Las respuestas 202 pueden contener un cuerpo con indicación del estado actual del recurso. En el caso de que fuera una petición de creación (ya sea con PUT o POST) contendrá una cabecera Location.


Más allá de CRUD: Hyperdata (HATEOAS) 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Es muy tentador cuando se comienza a trabajar con REST el definir APIs que modelan interfaces CRUD. Cada URI representa una tabla, o entidad de negocio, y mediante los verbos HTTP definimos las operaciones de edición y lectura. Como ya se comentado, este enfoque puede ser peligroso ya que podemos acoplar nuestra API web a la implementación concreta de nuestro modelo de persistencia.

Sin embargo el principal problema es que con el enfoque CRUD, en realidad no estamos diseñando una web de recursos de información, sino un conjunto de operaciones desconectadas entre sí que no representa realmente nuestro negocio. En este sentido, al diseñar CRUD, lo que estamos haciendo es exponer nuestra capa de datos mediante una API pública, y hacemos que todo el peso de interpretar e implementar la lógica de negocio caiga en el consumidor de nuestra API, con los lógicos problemas que esto acarrea. La API de nuestros servicios web deberían exponer los distintos casos de uso de nuestra aplicación, y no una mera interfaz de persistencia de datos. Es exactamente la misma diferencia que hay entre una aplicación de mantenimiento de tablas, y una aplicación con una UX orientada a que los usuarios completen casos de uso de nuestro negocio de la forma más efectiva posible.

Durante la primera fase de adopción de REST la mayoría de los proyectos definieron interfaces CRUD para sus recursos. Esto provocó que numerosos autores acuñara un nuevo término para REST: Hypermedia As The Engine Of Application State (HATEOAS). No es que realmente HATEOAS sea una cosa diferente de REST, sino que más bien es una aclaración al concepto de REST, haciéndo énfasis en el desarrollo de una web de servicios en contraposición a diseñar un conjunto inconexo de fuentes de datos. Pero realmente la visión original de REST[1] no se distingue de HATEOAS, aunque lamentablemente la parte más importante de esta filosofía, el crear una web de recursos de información interrelacionadas, fue ampliamente ignorada en un principio.

La web de servicios
^^^^^^^^^^^^^^^^^^^

El concepto de web de servicios, también llamado hyperdata, es sencillo de entender. Se basa en hacer énfasis en el aspecto más esencial de la web: los recursos no están aislados, sino que están interrelacionados mediante hiperenlaces, de forma que a partir de una página podamos descubrir el resto de la información que me interese.

Decimos que una API REST cumple HATEOAS, cuando:

* No es un conjunto de puntos de entrada desconectados entre si, sino una red de recursos de información conectados mediante hiperenlaces. De esta forma el consumidor de nuestros servicios web no necesita saber todas las URIs de nuestros recursos REST, sino que sólo tendría que conocer una única URI, quizás de un recurso "home" de nuestro sistema, y seguir los enlaces entre recursos para adquirir la información que vaya necesitando.
* Cada recurso debería poder ser servido en tantos formatos (tipos MIME) como tenga sentido.
* Las operaciones sobre cada recurso deberían estar codificadas en forma de enlaces dentro de éste. De esta forma no podremos cambiar el estado del sistema si no es siguiendo un enlace.

La idea general es aumentar al máximo la interoperabilidad disminuyendo la cantidad de información que necesitamos documentar para que un posible programador implemente un cliente para nuestra API. Esto sólo se puede conseguir si las capacidades de nuestro sistema se pueden descubrir siguiendo un conjunto sencillo de reglas o convenciones. Las reglas de HATEOAS hacen precisamente esto: por un lado no es necesario documentar todas las URIs de tu sistema, sino sólo una URI principal, desde la cual puedes descubrir el resto del sistema; por otro lado no hay que describir si para un determinado recurso la inserción o la actualización se realiza con PUT o con POST, o si para borrarlo basta hacer DELETE o hay que seguir otro proceso más complejo. Simplemente hay que examinar el documento obtenido por la anterior petición, y buscar que enlaces hay presentes. Estos enlaces son los que me indican qué conjunto de operaciones y recursos puedo hacer a continuación.

Por ejemplo en una tienda, podríamos tener una URI principal, 'http://www.shop.com/home', con enlaces a todos los subsistemas que ofrezcamos mediante REST.
---------------------------
GET /home HTTP/1.1
Host: www.shop.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json

{
  "links": [
    { "href": "/home", "title": "Shop home", "rel": "http://www.shop.com/linkrels/self" },
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/orders", "title": "Orders system", "rel": "http://www.shop.com/linkrels/orders" }
  ]

  ... other data ...
}
---------------------------
En este ejemplo la página principal actúa como directorio, y consiste principalmente en una lista de enlaces a los distintos subsistemas. En este ejemplo seguimos la convención de especificar en el atributo 'title' una descripción para humanos de lo que representa el enlace. Esto es interesante si el consumidor del recurso es realmente una UI, ya que podría generar una representación, tal vez un botón o un enlace HTML, de la acción representada por el enlace. Sin embargo el atributo realmente importante es 'rel'. En este atributo es donde se especifica el significado de seguir ese link. Son los posibles valores que puede tomar 'rel' dentro de nuestro sistema lo que tendremos que documentar. Ya existen algunos valores estandarizados[11], pero en este caso se ha optado por usar valores propietarios del sistema, indicándolo mediante el prefijo 'http://www.shop.com/linkrels'. Se ha usado una URL y no una URN, porque el significada de cada tipo de enlace debe ser documentado. Al usar una URL podemos indicar no sólo el tipo de enlace, sino la página web donde se encuentra la documentación sobre ese tipo de enlace. En dicha  documentación deberíamos especificar el significado exacto de la relación, y que métodos HTTP son admisibles.

Para resumir, en el enfoque HATEOAS la interfaz de nuestra API, que es lo que tenemos que documentar, consta de:

* Una URI principal de entrada a nuestro sistema.
* Los tipos MIME que vamos a usar.
* Una serie de convenciones sobre cómo consumir y representar dentro de cada documento, las acciones disponibles en el recurso que estamos accediendo.
* La forma más extendida de hacer lo anterior es mediante enlaces tipados mediante el atributo 'rel'. Habría que documentar pues lo que significa cada tipo de enlace y cómo consumirlo.

Consultas autodescubribles
^^^^^^^^^^^^^^^^^^^^^^^^^^

Lo más sencillo de modelar son las consultas. Como se explicó antes, las consultas se realizan mediante una petición que use el método GET a la URI del recurso colección. Sin embargo, el enfoque HATEOAS nos dice que en vez de tener que especificar una URI para cada colección, éstas deberían ser descubribles como enlaces dentro de otro recurso.

Supongamos el ejemplo anterior de la tienda, si seguimos el enlace marcado como 'linkrels/products', llegamos al siguiente documento:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json

{
  "links": [
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/books", "title": "Books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "Special offers", "rel": "http://www.shop.com/linkrels/products/search/offers" }
    { "href": "/shop/products{?maxprice,minprice,description,popularity}", "title": "Search products", "rel": "http://www.shop.com/linkrels/search", "template": true }
  ]

  ... other data ...
}
---------------------------
En este documento existen enlaces a algunas consultas frecuentes, como 'linkrels/products/search/books', o 'linkrels/products/search/offers'. Basta con hacer un GET a la URI de dichos enlaces para acceder a las consultas de 'libros disponibles en la tienda' y 'productos de oferta'.

Otro caso más interesante lo constituye los enlace de tipo '/linkrels/products/search', este tipo de enlace es una consulta genérica que admite parámetros. Si nos fijamos la URI es algo rara. En este caso no se trata de una URI en sí, sino de una URI Template[9]. Las URIs Template nos permiten averiguar las reglas según las cuales podemos construir una URI en función a los valores de una serie de parámetros. En este caso nos resultan muy útiles para saber que parámetros de consulta están disponibles y cómo construir una URI de consulta a partir de éstos. Actualmente se está trabajando en la estandarización de las URI Template[9], y si usamos una de las múltiples implementaciones que existen de este mecanismo[10], podemos aprovecharnos de este incipiente estándar sin apenas esfuerzo.

En el caso del ejemplo, la uri template es '/shop/products{?maxprice,minprice,description,popularity}', con lo cual podremos construir una consulta usando query strings como la siguiente '/shop/products?maxprice=100&description=vampires'. Las URI Template tienen una sintaxis muy rica que nos permiten una gran flexibilidad a la hora de definir nuestro esquema de URIs, para más detalles ver [9]. Aprovechando algunas de las implementaciones que existen[10] de este estándar podemos consumir las URI Template de forma sencilla, y generar la URI que necesitamos para realizar una acción en función de los parámetros que nos interesen.

Si seguimos el enlace para buscar las ofertas (rel='linkrels/products/search/offers'), el documento que nos devolvería sería el siguiente:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json

{
  "links": [
    { "href": "/shop/offers", "title": "Special offers (1st page)", "rel": "http://www.shop.com/linkrels/self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers/page/2?pasesize=10", "title": "Next page", "rel": "next" },
    { "href": "/shop/offers/page/{n}?pagesize=10", "title": "Go to page", "rel": "http://www.shop.com/linkrels/goto", "template": true },
    { "href": "/shop/offers{?orderby}", "title": "Offers ordered by", "rel": "http://www.shop.com/linkrels/orderby", "template": true }
  ]

  "products": [
    {
      "links": [
        { "href": "/shop/products/43", "title": "Fantastic book", "rel": "http://www.shop.com/linkrels/self" },
        { "href": "/shop/products/43/orderform?basket=234255", "title": "Add this product to my shopping list", "rel": "http://www.shop.com/linkrels/addtobasket" }
      ],
      "author": "Enrique Gómez Salas",
      "title": "Desventuras de un informático en Paris",
      "genre": "scifi",
      "price": { currency:"€", amount:5}
    },
    .... Más productos, hasta completar 10 (tamaño de la página) ...
  ]
}
---------------------------
Obsérvese que en vez de devolver una lista de productos, nos devuelve una página de resultados. En esta página de resultados podemos ver que tenemos más enlaces: a la siguiente página (rel='next'), saltar directamente a una página (rel='linkrels/goto') usando una URI template, o cambiar el orden en el que se nos presentan los datos (rel='linkrels/orderby'). Además cada entrada de resultados viene anotado con sus propios enlaces, que nos permiten realizar acciones sobre éstos.

Si seguimos el enlace (rel='next') se nos presenta el siguiente documento:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json

{
  "links": [
    { "href": "/shop/offers/page/2", "title": "Special offers (2nd page)", "rel": "http://www.shop.com/linkrels/self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "First page", "rel": "first" },
    { "href": "/shop/offers", "title": "Previous page", "rel": "prev" },
    { "href": "/shop/offers/page/3?pasesize=10", "title": "Next page", "rel": "next" },
    { "href": "/shop/offers/page/{n}?pagesize=10", "title": "Go to page", "rel": "http://www.shop.com/linkrels/goto", "template": true },
    { "href": "/shop/offers{?orderby}", "title": "Offers ordered by", "rel": "http://www.shop.com/linkrels/orderby", "template": true }
  ]

  "products": [
    .... Más productos, hasta completar 10 (tamaño de la página) ...
  ]
}
---------------------------
En este documento aparecen nuevos enlaces, como la posibilidad de volver atrás (rel='prev') o a la primera página (rel='first'). Estos enlaces no aparecían en el anterior documento, ya que éste representaba la primera página de resultados. En el enfoque HATEOAS no se deben incluir enlaces que representen acciones no admisibles por el estado actual del sistema, únicamente aparecerán los enlaces para las acciones que sean consistentes con el estado actual.

En el enfoque HATEOAS las consultas y la paginación vienen integradas. Los resultados de las búsquedas son más que meros contenedores pasivos de datos, sino que incluyen posibles acciones sobre éstos en forma de links. Por lo tanto es prácticamente gratis añadir enlaces que soporten un modelo de consultas paginadas.

Acciones como enlaces o formularios
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Parece que la parte de consulta de nuestro sistema es bastante intuitiva, pero, ¿cómo modelamos acciones que puedan cambiar el estado del sistema? Es simple, siguiendo los enlaces adecuados usando un verbo HTTP que represente un cambio de estado como PUT, POST y DELETE. Qué verbo usar, y qué efecto se produce, debería estar documentado para cada tipo de enlace. En cualquier caso yo recomiendo respetar la semántica original de los verbos HTTP[2b], para ello podemos seguir las indicaciones dadas en secciones anteriores sobre cuando usar cada verbo.

El diseño de APIs HATEOAS trabaja especialmente bien con la técnica anteriormente explicada de "URIs desechables". Volvamos al ejemplo la búsqueda de productos:
TODO uri='user/basket/234255/items/45sf245'
Se observa que el resultado incluye un enlace de tipo 'linkrels/basket'. No sólo eso sino que cada producto tiene además un enlace de tipo 'linkrels/addtobasket'. Si consultamos la documentación sobre este tipo de enlaces, vemos que el primero representa la cesta de la compra del usuario. Se puede consultar con GET, y sobreescribir por completo con PUT. Si sólo queremos añadir productos podemos usar POST. Veamos que ocurre si hacemos GET sobre la cesta:
TODO
--------------------------
--------------------------
Obtenemos una cesta vacía. No hemos tenido que crear la cesta de ninguna forma. Es un caso claro de uso de "URIs desechables". Mientras no rellenemos la cesta, esta seguirá siendo un recurso vacío y no necesitaríamos almacenarla de forma persistente. Veamos que pasa si hacemos POST:
TODO
--------------------------
--------------------------
Como veis hemos añadido 2 ejemplares de un libro. Lo más importante es que ha aparecido un enlace de tipo 'linkrels/payment' que nos permitirá comprar. Más adelante veremos cómo.

(añadir más ejemplares y un nuevo libro) Como POST no es idempotente si enviamos la siguiente petición:
TODO
--------------------------
--------------------------
Obtenemos la siguiente respuesta:
TODO.
--------------------------
--------------------------
Lo cual es totalmente consistente con el hecho de que la semántica de POST es aditiva. En este caso hemos añadido más ejemplares del libro y otro libro nuevo. En el caso de cada línea de pedido tenemos enlaces que nos permiten editar. Por ejemplo si hacemos la siguiente petición siguiendo el enlace de la primera línea de pedido:

(editar linea de pedido para actualizar numero de ejemplares) TODO
--------------------------
--------------------------
Hemos conseguido cambiar la cantidad de ejemplares que queremos. Si seguimos el enlace de tipo 'linkrek/basket', volvemos al carrito de la compra que queda como:
TODO
--------------------------
--------------------------
También podemos borrar una línea de pedido completa:
TODO
--------------------------
--------------------------
Y el carrito quedaría:
TODO
--------------------------
--------------------------
Ahora sólo nos queda pagar. Tan sencillo como hacer PUT con la información de nuestro medio de pago:
TODO
--------------------------
--------------------------
De nuevo un ejemplo de "URI desechable". El resultado de esta petición es:
TODO
--------------------------
--------------------------
El servidor se nos indica que tenemos un recibo de nuestro pedido. Si hacemos GET sobre éste:
TODO
--------------------------
--------------------------
Vemos que podemos hacer polling sobre él para saber el estado de nuesto pedido, o cancelarlo y que nos devuelvan el dinero. Cuando en el futuro nuestro pedido esté completo, si volvemos a hacer GET:
TODO
--------------------------
--------------------------
Con lo cual se ve que una vez enviado, no es tan sencillo como devolver el dinero, pero sí podemos hacer una devolución del producto.

Obviamente estoy simplificando. En realidad el workflow es probable que sea más complejo, y por supuesto cada petición debería ir protegida con las técnicas explicadas en las secciones anteriores (al menos HTTPS con autenticación digest).

WSDL no es necesario: Servicios web autodescriptivos
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Como se aprecia en el ejemplo anterior cada documento nos va dando los siguientes pasos, y es cuestión de seguir los enlaces usando los métodos adecuados según la semántica HTTP[2b]. Pero, ¿cómo sabemos que información enviar y en qué formatos? Una cosa interesante sería hacer una petición con el método OPTIONS:
TODO
--------------------------
--------------------------
El servidor nos responde con los métodos admisibles por dicha URI. Siguiendo la semántica HTTP, y quizás algunas convenciones sobre éstos que habría que documentar, el cliente puede averiguar de forma automática las operaciones disponibles. Para saber qué tipos MIME soportamos debemos emitir una petición HEAD:
TODO
--------------------------
--------------------------
El servidor nos ha respondido con información, como los tipos MIME soportados. Dichos tipos MIME y cómo usarlos forman parte de la documentación de nuestra API, con lo cual el cliente sabe qué tipo de información mandar. Como vemos no es necesario documentar mucho, únicamente los tipos MIME soportados y las convenciones sobre cómo usar los verbos HTTP para consumirlos. El resto es seguir enlaces.

Siguiendo esta filosofía se puede entender por qué en el diseño de APIs REST no se usa nada equivalente al WSDL de los servicios web clásicos. Los documentos WSDL nos proporcionan un medio de automatizar los aspectos sintácticos de interoperabilidad entre servicios. Con un generador de código podíamos procesar un WSDL para generar el código necesario para analizar y construir los mensajes SOAP y realizar las llamadas a los correspondientes puntos de servicio. Mediante HATEOAS las reglas a nivel sintáctico son las mismas para todas las aplicaciones, con lo cual basta un único framework para todas las APIs que sigan la filosofía HATEOAS. Lo único que puede variar entre un sistema y otro son los formatos concretos de documentos a intercambiar (XML, JSON, ATOM…), pero para ello basta tener una librería de análisis  y generación de dichos formatos. Si encima los formatos a usar son estándar, podemos usar una librería de terceros o de la plataforma para procesar los documentos.

No es de extrañar que los intentos de acercar WSDL a REST[15] o de crear equivalentes a WSDL en REST, como es el caso de WADL[16], no hayan tenido realmente mucho éxito. Al fin y al cabo no aportan mucho a lo que ya te da la filosofía HATEOAS de diseño de APIs REST.

Referencias y bibliografía
--------------------------

[1] El acrónimo REST responde a "REpresentational State Transfer". El estilo arquitectónico REST fue descrito por primera vez por Roy Thomas Fielding, allá por el año 2000 (sí, ha llovido mucho desde entonces), si quieres leer el articulo original está públicamente accesible aquí: http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

[2] Hyper Text Transfer Protocol 1.1: http://tools.ietf.org/html/rfc2616
[2b] Aclaración sobre la semántica de los métodos HTTP: http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-18

[3] Basic Profile Version 1.0: http://www.ws-i.org/profiles/BasicProfile-1.0-2004-04-16.html

[4] La pila ISO de protocolos de red: http://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-X.200-199407-I!!PDF-E&type=items y también http://en.wikipedia.org/wiki/OSI_model

[5] Uniform Resource Identifier: http://www.ietf.org/rfc/rfc3986.txt

[6] Directorio de tipos MIME estandarizados por IANA: http://www.iana.org/assignments/media-types/index.html

[7] Concurrencia optimista: http://en.wikipedia.org/wiki/Optimistic_concurrency_control y también http://www.w3.org/1999/04/Editing/

[8] Autenticación "Basic" y "Digest" de HTTP: http://tools.ietf.org/html/rfc2617

[9] URI Templates specification: http://tools.ietf.org/html/rfc6570

[10] Algunas implementaciones de URI Templates: http://code.google.com/p/uri-templates/wiki/Implementations

[11] Algunos valores de 'rel' estándarizados: http://www.iana.org/assignments/link-relations/link-relations.xml

[12] PATCH Method for HTTP: http://tools.ietf.org/html/rfc5789

[13] An Extensible Markup Language (XML) Patch Operations Framework Utilizing XML Path Language (XPath) Selectors: http://tools.ietf.org/html/rfc5261

[14] JSON Patch: http://tools.ietf.org/html/draft-ietf-appsawg-json-patch-01
  
[15] WSDL 2.0: http://www.w3.org/2002/ws/desc/

[16] WADL: http://wadl.java.net/
