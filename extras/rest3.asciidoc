Introducción a las APIs REST con HTTP (2): Hypermedia APIs (HATEOAS)
====================================================================
Enrique J. Amodeo_Rubio <eamodeorubio@gmail.com>
:Blog: http://eamodeorubio.wordpress.com
:Twitter: @eamodeorubio

Introducción
------------

Es muy tentador cuando se comienza a trabajar con REST el definir APIs que modelan interfaces CRUD. Cada URI representa una tabla, o entidad de negocio, y mediante los verbos HTTP definimos las operaciones de edición y lectura. Como ya se comentado, este enfoque puede ser peligroso ya que podemos acoplar nuestra API web a la implementación concreta de nuestro modelo de persistencia.

Sin embargo el principal problema es que con el enfoque CRUD, en realidad no estamos diseñando una web de recursos de información, sino un conjunto de operaciones desconectadas entre sí que no representa realmente nuestro negocio. En este sentido, al diseñar CRUD, lo que estamos haciendo es exponer nuestra capa de datos mediante una API pública, y hacemos que todo el peso de interpretar e implementar la lógica de negocio caiga en el consumidor de nuestra API, con los lógicos problemas que esto acarrea. La API de nuestros servicios web deberían exponer los distintos casos de uso de nuestra aplicación, y no una mera interfaz de persistencia de datos. Es exactamente la misma diferencia que hay entre una aplicación de mantenimiento de tablas, y una aplicación con una UX orientada a que los usuarios completen casos de uso de nuestro negocio de la forma más efectiva posible.

Por supuesto esto no es ningún problema si lo que queremos hacer es precisamente eso, exponer una capa de persistencia o acceso a datos sin ningún tipo de lógica más allá de validaciones básicas. Pero normalmente no es eso lo que se persigue, y nuestra API debería ser capaz de ofrecer un poco más de inteligencia.

Durante la primera fase de adopción de REST la mayoría de los proyectos definieron interfaces CRUD para sus recursos. Esto provocó que numerosos autores acuñara un nuevo término para REST: Hypermedia As The Engine Of Application State (HATEOAS), para señalizar que la API se basa en un enfoque de hypermedia y no CRUD. No es que realmente HATEOAS sea una cosa diferente de REST, sino que más bien es una aclaración al concepto de REST, haciéndo énfasis en el desarrollo de una web de servicios en contraposición a diseñar un conjunto inconexo de fuentes de datos. Pero realmente la visión original de REST[1] no se distingue de HATEOAS, aunque lamentablemente la parte más importante de esta filosofía, el crear una web de recursos de información interrelacionadas, fue ampliamente ignorada en un principio.

El concepto de hypermedia
-------------------------

El concepto de hypermedia es sencillo de entender. Se basa en hacer énfasis en el aspecto más esencial de la web: los recursos no están aislados, sino que están interrelacionados mediante hiperenlaces, de forma que a partir de una página podamos descubrir como acceder al resto de la información que me interesa mediante enlaces, y descubrir que acciones podemos realizar mediante controles presentes en el documento.

Decimos que una API REST es HATEOAS, cuando:

* No es un conjunto de puntos de entrada desconectados entre si, sino una red de recursos de información conectados mediante hiperenlaces. De esta forma el consumidor de nuestros servicios web no necesita saber todas las URIs de nuestros recursos REST, sino que sólo tendría que conocer una única URI, quizás de un recurso "home" de nuestro sistema, y seguir los enlaces entre recursos para adquirir la información que vaya necesitando.
* Cada recurso debería poder ser servido en tantos formatos (tipos MIME) como tenga sentido.
* Las operaciones sobre cada recurso deberían estar codificadas en forma de controles dentro de los documentos que sirven como representación de éste. De esta forma no podremos cambiar el estado del sistema si no es usando un control presente en el propio recurso.

La idea general es aumentar al máximo la interoperabilidad disminuyendo la cantidad de información que necesitamos documentar para que un posible programador implemente un cliente para nuestra API. Esto sólo se puede conseguir si las capacidades de nuestro sistema se pueden descubrir siguiendo un conjunto sencillo de reglas o convenciones. Las reglas de HATEOAS hacen precisamente esto: por un lado no es necesario documentar todas las URIs de tu sistema, sino sólo una URI principal, desde la cual puedes descubrir el resto del sistema; por otro lado no hay que describir si para un determinado recurso la inserción o la actualización se realiza con PUT o con POST, o si para borrarlo basta hacer DELETE o hay que seguir otro proceso más complejo. Simplemente hay que examinar el documento obtenido por la anterior petición, y buscar que enlaces y controles hay presentes. Estos enlaces y controles son los que me indican qué conjunto de operaciones y recursos puedo hacer a continuación.

Por ejemplo en una tienda, podríamos tener una URI principal, 'http://www.shop.com/home', con enlaces a todos los subsistemas que ofrezcamos mediante REST.
---------------------------
GET /home HTTP/1.1
Host: www.shop.com
Accept: application/x-shop.home+json,application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.home+json

{
  "links": [
    { "href": "/home", "title": "Shop home", "rel": "self" },
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/orders", "title": "Orders system", "rel": "http://www.shop.com/linkrels/orders" }
  ]

  ... other data ...
}
---------------------------
En este ejemplo la página principal actúa como directorio, y consiste principalmente en una lista de enlaces a los distintos subsistemas. En este ejemplo seguimos la convención de especificar en el atributo 'title' una descripción para humanos de lo que representa el enlace. Esto es interesante si el consumidor del recurso es realmente una UI, ya que podría generar una representación, tal vez un botón o un enlace HTML, de la acción representada por el enlace. Sin embargo el atributo realmente importante es 'rel'. En este atributo es donde se especifica el significado de seguir ese link. Son los posibles valores que puede tomar 'rel' dentro de nuestro sistema lo que tendremos que documentar. Ya existen algunos valores estandarizados[5], pero en este caso se ha optado por usar valores propietarios del sistema, indicándolo mediante el prefijo 'http://www.shop.com/linkrels'. Se ha usado una URL y no una URN, porque el significada de cada tipo de enlace debe ser documentado. Al usar una URL podemos indicar no sólo el tipo de enlace, sino la página web donde se encuentra la documentación sobre ese tipo de enlace. En dicha  documentación deberíamos especificar el significado exacto de la relación, y que métodos HTTP son admisibles.

Para resumir, en el enfoque HATEOAS la interfaz de nuestra API, que es lo que tenemos que documentar, consta de:

* Una URI principal de entrada a nuestro sistema.
* Los tipos MIME que vamos a usar.
* Una serie de convenciones sobre cómo consumir y representar dentro de cada documento, las acciones disponibles en el recurso que estamos accediendo.
* La forma más extendida de hacer lo anterior es mediante enlaces tipados mediante el atributo 'rel'. Habría que documentar pues lo que significa cada tipo de enlace y cómo consumirlo.

Veamos todo esto en más detalle.

Consultas autodescubribles
--------------------------

Lo más sencillo de modelar son las consultas. Como se explicó antes, las consultas se realizan mediante una petición que use el método GET a la URI del recurso colección. Sin embargo, el enfoque HATEOAS nos dice que en vez de tener que especificar una URI para cada colección, éstas deberían ser descubribles como enlaces dentro de otro recurso.

Supongamos el ejemplo anterior de la tienda, si seguimos el enlace marcado como 'linkrels/products', llegamos al siguiente documento:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.collection+json

{
  "links": [
    { "href": "/shop/products", "title": "Product catalog", "rel": "self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/books", "title": "Books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "Special offers", "rel": "http://www.shop.com/linkrels/products/search/offers" }
    { "href": "/shop/products{?maxprice,minprice,description,popularity}", "title": "Search products", "rel": "http://www.shop.com/linkrels/search", "template": true }
  ],

  ... other data ...
}
---------------------------
En este documento existen enlaces a algunas consultas frecuentes, como 'linkrels/products/search/books', o 'linkrels/products/search/offers'. Basta con hacer un GET a la URI de dichos enlaces para acceder a las consultas de 'libros disponibles en la tienda' y 'productos de oferta'.

Un tipo de enlace curioso es rel="self", que es estándar y que indica la URL del recurso en si. Es útil cuando encontramos el recurso embebido dentro de otro recurso.

Otro caso más interesante lo constituye los enlace de tipo '/linkrels/products/search', este tipo de enlace es una consulta genérica que admite parámetros. Si nos fijamos la URI es algo rara. En este caso no se trata de una URI en sí, sino de una URI Template[3]. Las URIs Template nos permiten averiguar las reglas según las cuales podemos construir una URI en función a los valores de una serie de parámetros. En este caso nos resultan muy útiles para saber que parámetros de consulta están disponibles y cómo construir una URI de consulta a partir de éstos. Actualmente se está trabajando en la estandarización de las URI Template[3], y si usamos una de las múltiples implementaciones que existen de este mecanismo[4], podemos aprovecharnos de este incipiente estándar sin apenas esfuerzo.

En el caso del ejemplo, la uri template es '/shop/products{?maxprice,minprice,description,popularity}', con lo cual podremos construir una consulta usando query strings como la siguiente '/shop/products?maxprice=100&description=vampires'. Las URI Template tienen una sintaxis muy rica que nos permiten una gran flexibilidad a la hora de definir nuestro esquema de URIs, para más detalles ver [3]. Aprovechando algunas de las implementaciones que existen[4] de este estándar podemos consumir las URI Template de forma sencilla, y generar la URI que necesitamos para realizar una acción en función de los parámetros que nos interesen.

Si seguimos el enlace para buscar las ofertas (rel='linkrels/products/search/offers'), el documento que nos devolvería sería el siguiente:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.collection+json

{
  "links": [
    { "href": "/shop/offers", "title": "Special offers (1st page)", "rel": "self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers/page/2?pasesize=10", "title": "Next page", "rel": "next" },
    { "href": "/shop/offers/page/{n}?pagesize=10", "title": "Go to page", "rel": "http://www.shop.com/linkrels/goto", "template": true },
    { "href": "/shop/offers{?orderby}", "title": "Offers ordered by", "rel": "http://www.shop.com/linkrels/orderby", "template": true }
  ],
  "items": [
    {
      "links": [
        { "href": "/shop/products/43", "title": "Fantastic book", "rel": "self" },
        { "href": "/shop/products/43/orderform?basket=234255", "title": "Add this product to my shopping list", "rel": "http://www.shop.com/linkrels/addtobasket" }
      ],
      "author": "Enrique Gómez Salas",
      "title": "Desventuras de un informático en Paris",
      "genre": "scifi",
      "price": { currency:"€", amount:5}
    },
    .... Más productos, hasta completar 10 (tamaño de la página) ...
  ]
}
---------------------------
Obsérvese que en vez de devolver una lista de productos, nos devuelve una página de resultados. En esta página de resultados podemos ver que tenemos más enlaces: a la siguiente página (rel='next'), saltar directamente a una página (rel='linkrels/goto') usando una URI template, o cambiar el orden en el que se nos presentan los datos (rel='linkrels/orderby'). Además cada entrada de resultados viene anotado con sus propios enlaces, que nos permiten realizar acciones sobre éstos.

Si seguimos el enlace (rel='next') se nos presenta el siguiente documento:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.collection+json

{
  "links": [
    { "href": "/shop/offers/page/2", "title": "Special offers (2nd page)", "rel": "self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "First page", "rel": "first" },
    { "href": "/shop/offers", "title": "Previous page", "rel": "prev" },
    { "href": "/shop/offers/page/3?pasesize=10", "title": "Next page", "rel": "next" },
    { "href": "/shop/offers/page/{n}?pagesize=10", "title": "Go to page", "rel": "http://www.shop.com/linkrels/goto", "template": true },
    { "href": "/shop/offers{?orderby}", "title": "Offers ordered by", "rel": "http://www.shop.com/linkrels/orderby", "template": true }
  ],
  "items": [
    .... Más productos, hasta completar 10 (tamaño de la página) ...
  ]
}
---------------------------
En este documento aparecen nuevos enlaces, como la posibilidad de volver atrás (rel='prev') o a la primera página (rel='first'). Estos enlaces no aparecían en el anterior documento, ya que éste representaba la primera página de resultados. En el enfoque HATEOAS no se deben incluir enlaces que representen acciones no admisibles por el estado actual del sistema, únicamente aparecerán los enlaces para las acciones que sean consistentes con el estado actual.

En el enfoque HATEOAS las consultas y la paginación vienen integradas. Los resultados de las búsquedas son más que meros contenedores pasivos de datos, sino que incluyen posibles acciones sobre éstos en forma de links. Por lo tanto es prácticamente gratis añadir enlaces que soporten un modelo de consultas paginadas.

Controles hypermedia
--------------------

Parece que la parte de consulta de nuestro sistema es bastante intuitiva, pero, ¿cómo modelamos acciones que puedan cambiar el estado del sistema? Es simple, por cada operación consistente con el estado actual del sistema, debemos incluir un "control" que nos permita realizarla. Simplemente debemos inspeccionar el documento que representa un recurso en busca de controles para averiguar que operaciones podemos realizar sobre un recurso. Qué controles están presente y cuales no varían tanto con el tipo del recurso como con el estado concreto del sistema. Para un mismo recurso algunos controles pueden estar disponibles, o simplemente no aparecer en el documento, en función de si su ejecución es compatible con el estado del sistema. Por lo tanto si una acción no puede ser ejecutada en el estado en el que se encuentra el sistema, el control para dicha acción no se incluye en el documento.

A continuación se hace una introducción a como implementar controles en una API HATEOAS.

Acciones como enlaces
~~~~~~~~~~~~~~~~~~~~~

La forma más sencilla de control es el enlace. Ya hemos visto estos enlaces en acción cuando se explicó las consultas, ahora nos ocuparemos de como modelar otras operaciones usando enlaces.

Un enlace, además de con el método GET, puede ser seguido usando un verbo HTTP que represente un cambio de estado, como PUT, POST y DELETE. Qué verbo usar, y qué efecto se produce, debería estar documentado para cada tipo de enlace. En cualquier caso yo recomiendo respetar la semántica original de los verbos HTTP[2], para ello podemos seguir las indicaciones dadas en capítulos anteriores sobre cuando usar cada verbo.

Sin embargo, por claridad e interoperabilidad, se suele añadir un atributo "rel" a los enlaces, indicando cuál es la semántica de seguir ese enlace. En nuestra API deberemos documentar cada valor que puede aparecer en "rel", indicando que significa seguir un enlace marcado como tal y que verbos HTTP se soportan.

El diseño de APIs HATEOAS trabaja especialmente bien con la técnica explicada en el capítulo anterior de "URIs desechables". En el ejemplo anterior se observa que el resultado incluye un enlace de tipo 'linkrels/basket'. No sólo eso sino que cada producto tiene además un enlace de tipo 'linkrels/addtobasket'. Si consultamos la documentación sobre este tipo de enlaces, vemos que el primero representa la cesta de la compra del usuario. Se puede consultar con GET, y sobreescribir por completo con PUT. Veamos que ocurre si hacemos GET sobre la cesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.basket+json

{
  "links": [
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "self"},
    { "href": "/shop/basket/234255/items", "title": "Products in the shopping list", "rel": "http://www.shop.com/linkrels/basket/items" },
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "Special offers", "rel": "http://www.shop.com/linkrels/products/search/offers" }
  ],
  "items": [],
  "total": { currency: "€", amount: 0 }
}
---------------------------
Obtenemos una cesta vacía. No hemos tenido que crear la cesta de ninguna forma. Es un caso claro de uso de "URIs desechables". Mientras no rellenemos la cesta, esta seguirá siendo un recurso vacío y no necesitaríamos almacenarla de forma persistente ya que su representación se puede generar desde cero.

Para añadir productos a la cesta podemos usar el enlace con rel="/linkrels/basket/items". La documentación nos indica que hagamos un POST para crear una linea de pedido y que después hagamos un PUT indicando el identificador de producto y la cantidad.

Primero pedimos abrir una nueva línea de pedido en la cesta de la compra:
---------------------------
POST /shop/basket/234255/items HTTP/1.1
Host: www.shop.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.shop.com/shop/basket/234255/items/ecafadfj312_dad0348

---------------------------
Ahora confirmar la línea de pedido, indicando producto y cantidad
---------------------------
PUT /shop/basket/234255/items/ecafadfj312_dad0348 HTTP/1.1
Host: www.shop.com
Accept: application/json
Content-Type: application/x-shop.orderitem+json

{
  "quantity": 2,
  "product-ref": "http://www.shop.com/shop/products/43"
}
---------------------------
Y la respuesta del servidor, con la linea de pedido creada:
---------------------------
HTTP/1.1 200 OK
Content-Type: application/x-shop.orderitem+json;charset=utf-8

{
  "links": [
    { "href": "/shop/basket/234255/items/ecafadfj312_dad0348", "title": "this order line", "rel": "self" },
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"}
  ],
  "quantity": 2,
  "product-ref": "http://www.shop.com/shop/products/43"
}
---------------------------
Para ver como queda la lista de la compra seguimos el enlace de tipo rel="/linkrels/basket":
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.basket+json

{
  "links": [
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "self"},
    { "href": "/shop/basket/234255/items", "title": "Products in the shopping list", "rel": "http://www.shop.com/linkrels/basket/items" },
    { "href": "/shop/basket/234255/payment", "title": "Products in the shopping list", "rel": "http://www.shop.com/linkrels/basket/payment" },
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "Special offers", "rel": "http://www.shop.com/linkrels/products/search/offers" }
  ],
  "items": [
    {
      "links": [
        { "href": "/shop/basket/234255/items/ecafadfj312_dad0348", "title": "this order line", "rel": "self" },
        { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"}
      ],
      "quantity": 2,
      "product-ref": "http://www.shop.com/shop/products/43"
    }
  ],
  "total": { currency: "€", amount: 10 }
}
--------------------------
Como veis hemos añadido 2 ejemplares de un libro. Lo más importante es que ha aparecido un enlace de tipo 'linkrels/payment' que nos permitirá comprar. Más adelante veremos cómo. Si quisiéramos editar la línea de pedido basta con hacer PUT o PATCH a la URL de la línea. No es necesario memorizar dicha URL ya que viene siempre en los enlaces tipo rel="self". Si queremos anular la línea de pedido es tan simple como hacer DELETE.

Ahora sólo nos queda pagar. Tan sencillo como hacer PUT sobre la URL especificada en el enlace "linkrels/basket/payment" con la información pertinente:
---------------------------
PUT /shop/basket/234255/payment HTTP/1.1
Host: www.shop.com
Accept: application/x-shop.payment+json
Content-Type: application/x-shop.payment+json

{
  "method":"visa",
  "card": {
    "cardnumber": 1234567812345678,
    "secnumber":333,
    "expiration": "08/2016",
    "cardholder": "Pepe Pérez",
  }
}
---------------------------
La respuesta
---------------------------
HTTP/1.1 200 Ok
Date: Tue, 27 Dec 2012 05:25:19 GMT
Expires: Tue, 27 Dec 2012 05:25:39 GMT
Cache-Control: max-age=20
Content-Type: application/x-shop.payment+json

{
  "links":[
    { "href": "/shop/basket/234255/payment", "title": "Payment", "rel": "self"},
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"}
  ],
  "method":"visa",
  "card": {
    "cardnumber": 1234567812345678,
    "secnumber":333,
    "expiration": "08/2016",
    "cardholder": "Pepe Pérez",
  },
  "status":"in progress"
}
---------------------------
El pago ha sido aceptado, pero todavía no esta confirmado. A partir de ahí es cuestión de hacer polling sobre el recurso hasta que el pago finalize, para ello nos guiaremos por la cabecera Cache-Control. Finalmente cuando el pago se confirma:
---------------------------
HTTP/1.1 200 Ok
Date: Tue, 27 Dec 2012 05:30:00 GMT
Expires: Tue, 27 Dec 2012 11:30:00 GMT
Cache-Control: max-age=21600
Content-Type: application/x-shop.payment+json

{
  "links":[
    { "href": "/shop/basket/234255/payment", "title": "Payment", "rel": "self"},
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/basket/234255/invoice", "title": "Invoice", "rel": "http://www.shop.com/linkrels/invoice"}
  ],
  "method":"visa",
  "card": {
    "cardnumber": 1234567812345678,
    "secnumber":333,
    "expiration": "08/2016",
    "cardholder": "Pepe Pérez",
  },
  "status":"confirmed"
}
---------------------------
Observemos que ahora aparece un enlace "/linkrels/invoice" para obtener la factura. Este es un caso típico en el que podemos usar varios tipos mime, en función del formato en el que el cliente quiera la factura: PDF, HTML, DOC, etc.

Obviamente estoy simplificando. En realidad el workflow de pago es probablemente mucho más complejo, y por supuesto cada petición debería ir protegida con las técnicas explicadas en las secciones anteriores (al menos HTTPS con autenticación digest).


Acciones como formularios
~~~~~~~~~~~~~~~~~~~~~~~~~

El uso de enlaces como controles está bien para acciones simples, normalmente de estilo CRUD y que sólo requieran parámetros sencillos que puedan ser enviados mediante la querystring. Como nivel de complejidad máximo podemos usar URI Templates.

Sin embargo para operaciones más complejas, y que normalmente necesitan enviar un documento en el cuerpo de la petición HTTP es más apropiado usar formularios.

Otra forma de añadir un producto al carrito hubiera sido usar el enlace tipo rel="/linkrels/addtobasket". Recordemos el producto 43 tenía la siguiente información:
--------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.product+json

{
  "links": [
    { "href": "/shop/products/43", "title": "Fantastic book", "rel": "self" },
    { "href": "/shop/products/43/orderform?basket=234255", "title": "Add this product to my shopping list", "rel": "http://www.shop.com/linkrels/addtobasket" }
  ],
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:5}
}
--------------------------
Si seguimos el enlace rel="/linkrels/addtobasket" usando GET, obtenemos:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.form+json

{
  "links": [
    { "href": "/shop/products/43/orderform?basket=234255", "title": "Order product form", "rel": "self"},
    { "href": "/shop/basket/234255/items/ecafadfj312_dad0348", "title": "Order product form target", "rel": "http://www.shop.com/linkrels/target"},
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "http://www.shop.com/linkrels/basket"},
    { "href": "/shop/products/43", "title": "Product to add", "rel": "http://www.shop.com/linkrels/product"}
  ],
  "method": "PUT",
  "type": "application/x-shop.orderitem+json",
  "body": {
    "quantity": 1,
    "product-ref": "http://www.shop.com/shop/products/43"
  }
}
--------------------------
El documento resultante no es más que la versión JSON de un formulario ya relleno con información. Veamos de que consta un formulario JSON.
* Dentro de "links" el enlace de tipo rel="/linkrels/target" nos indica cual es la URL sobre la que debemos la realizar la petición para procesar este "formulario".
* El campo "method" nos indica el método HTTP a utilizar cuando hagamos la petición a la URL "target"
* El campo "type" nos indica el tipo mime que debe tener el cuerpo de la petición.
* El campo "body" nos proporciona una instancia de datos que podemos usar en el cuerpo de la petición.

En este caso el campo "body" y el link "target" aparecen ya informados. De esta forma simplemente sería hacer un PUT a la URL que nos indican con los datos que aparecen en el formulario. Esto tendría como resultado añadir un ejemplar del producto "43" a la cesta de la compra, tal y como hicimos en el ejemplo de la sección anterior.

El uso de formularios es un poco más avanzado que el uso de links sencillos. Pero a la vez nos permite más potencia. En este ejemplo tenemos dos ventajas:
* Nos ahorramos hacer un POST a la cesta de la compra para conseguir crear una nueva linea de pedido "virtual". En el propio formulario nos viene la URL de una nueva linea de pedido.
* Los datos a informar en la petición PUT ya nos vienen completados desde el servidor.

En general el uso de la técnica de formularios nos simplifica el uso de URIs desechables, ya que no necesitamos en ningún momento hacer un POST. También nos ayudan a autodescribir mejor nuestra API.

Veamos un ejemplo más, supongamos que para tomar partido de esta técnica ahora el carrito de la compra es como sigue:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/x-shop.basket+json

{
  "links": [
    { "href": "/shop/basket/234255", "title": "My shopping list", "rel": "self"},
    { "href": "#new-order-form", "title": "Add a product to this shopping list", "rel": "http://www.shop.com/linkrels/addtobasket" }
    { "href": "/shop/products", "title": "Product catalog", "rel": "http://www.shop.com/linkrels/products" },
    { "href": "/shop/books", "title": "Search books available in the shop", "rel": "http://www.shop.com/linkrels/products/search/books" },
    { "href": "/shop/offers", "title": "Special offers", "rel": "http://www.shop.com/linkrels/products/search/offers" }
  ],
  "items": [],
  "total": { currency: "€", amount: 0 },
  "new-order-form": {
    "links": [
      { "href": "/shop/basket/234255#new-order-form", "title": "Order product form", "rel": "self"},
      { "href": "/shop/basket/234255/items/ecafadfj312_dad0348", "title": "Order product form target", "rel": "http://www.shop.com/linkrels/target"}
    ],
    "method": "PUT",
    "type": "application/x-shop.orderitem+json"
  }
}
---------------------------
Ahora añadir productos al carrito es mucho más sencillo que antes. No necesitamos hacer un GET a la colección de "items", para después hacer un POST y conseguir una URL desechable. Ahora es tan simple como rellenar el formulario incrustado en el carrito y ejecutarlo. Además de que el procesamiento es más sencillo, ahora nos ahorramos dos llamadas de red.

En este caso el formulario no tiene campo "body", lo que indica que el cliente deberá indicar toda la información. Afortunadamente el campo "type" nos indica el tipo mime apropiado, cuya documentación debemos consultar para saber como implementar el cliente.

WSDL no es necesario: Servicios web autodescriptivos
----------------------------------------------------

Como se aprecia en el ejemplo anterior cada documento nos va dando los siguientes pasos, y es cuestión de seguir los enlaces usando los métodos adecuados según la semántica HTTP[2]. Pero, ¿cómo sabemos que información enviar y en qué formatos? Una cosa interesante sería hacer una petición con el método OPTIONS. Recordemos el ejemplo que apareció anteriormente:
--------------------------
OPTIONS /rest/libro/465 HTTP/1.1
Host: www.server.com

--------------------------
Y la respuesta:
--------------------------
HTTP/1.1 200 OK
Allow: GET, PUT, POST, OPTIONS, HEAD, DELETE, PATCH
Accept-Patch: application/book-diff+json
Content-Length: 0

--------------------------
El servidor nos responde con los métodos admisibles por dicha URI, si soporta o no el método PATCH. Siguiendo la semántica HTTP, y quizás algunas convenciones sobre éstos que habría que documentar, el cliente puede averiguar de forma automática las operaciones disponibles. Adicionalmente OPTIONS nos permite un cuerpo en la respuesta, donde se especificarían detalles adicionales a nivel de aplicación.

Otro método útil es HEAD. El método HEAD es idéntico a GET, excepto que el servidor no devuelve datos y por lo tanto no intenta acceder a información ni realizar ninguna consulta. La utilidad de HEAD está en que nos devuelve exactamente las misma cabeceras y respuestas HTTP que como si hubiéramos hecho un GET.
Por ejemplo:
--------------------------
HEAD /rest/libro/465 HTTP/1.1
Host: www.server.com
If-None-Match: W/"686897696a7c876b7e"
If-Modified-Since: Wed, 01 Sep 2012 13:24:52 GMT
Accept: application/json

--------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8
Date: Tue, 27 Dec 2012 05:25:19 GMT
Expires: Tue, 27 Dec 2012 11:25:19 GMT
Cache-Control: max-age=21600
Last-Modified: Tue, 27 Dec 2012 03:25:19 GMT
ETag: W/"9082aff9627ab7cb60"

---------------------------
Con lo que sabemos si el recurso ha cambiado o no y su nuevo ETag. HEAD es muy útil para comprobar si un link funciona como el cliente espera. Pero también nos permite averiguar que tipos mime soporta. Si la respuesta hubiera sido:
---------------------------
HTTP/1.1 406 Not acceptable

---------------------------
Entonces sabríamos si dicho recurso soporta el tipo mime o no por adelantado.

Usando una mezcla de HEAD y OPTIONS podemos inspeccionar las capacidades de un recurso REST

Siguiendo esta filosofía se puede entender por qué en el diseño de APIs REST no se usa nada equivalente al WSDL de los servicios web clásicos. Los documentos WSDL nos proporcionan un medio de automatizar los aspectos sintácticos de interoperabilidad entre servicios. Con un generador de código podíamos procesar un WSDL para generar el código necesario para analizar y construir los mensajes SOAP y realizar las llamadas a los correspondientes puntos de servicio.

Sin embargo la dificultad de consumir una API pública no está en la sintaxis de los formatos de datos, sino en la semántica de éstos. HATEOAS nos proporciona unas reglas y patrones mínimos y de bajo acoplamiento que nos permiten homogeneizar la forma de consumir nuestros servicios. La parte importante queda en la documentación y en la definición de los tipos mime a utilizar. Lo único que se necesita para desarrollar un cliente que pueda consumir una API HATEOAS es:
* Una primera URL como punto de entrada a nuestro sistema.
* Una documentación describiendo la semántica de los tipos mime específicos de nuestra API. Esto no sólo incluye las entidades, sino también los formularios. Se recomienda basar dichos tipos en otros formatos ya existentes (JSON, XML, ATOM, HTML). La descripción de la estructura sintáctica la podemos dejar en mános de herramientas que consuman XML Schema o Relax NG o algo similar.
* Una documentación describiendo como consumir cada tipo de enlace (métodos a usar, tipos mime aceptables, patrones de uso).

No es de extrañar que los intentos de acercar WSDL a REST[6] o de crear equivalentes a WSDL en REST, como es el caso de WADL[7], no hayan tenido realmente mucho éxito. Al fin y al cabo no aportan mucho a lo que ya te da la filosofía HATEOAS de diseño de APIs REST.

Referencias y bibliografía
--------------------------

[1] El acrónimo REST responde a "REpresentational State Transfer". El estilo arquitectónico REST fue descrito por primera vez por Roy Thomas Fielding, allá por el año 2000 (sí, ha llovido mucho desde entonces), si quieres leer el articulo original está públicamente accesible aquí: http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

[2] Aclaración sobre la semántica de los métodos HTTP: http://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-18

[3] URI Templates specification: http://tools.ietf.org/html/rfc6570

[4] Algunas implementaciones de URI Templates: http://code.google.com/p/uri-templates/wiki/Implementations

[5] Algunos valores de 'rel' estándarizados: http://www.iana.org/assignments/link-relations/link-relations.xml

[6] WSDL 2.0: http://www.w3.org/2002/ws/desc/

[7] WADL: http://wadl.java.net/
