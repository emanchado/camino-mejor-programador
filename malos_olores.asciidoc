Malos olores del código
=======================
Carlos Blé_Jurado <carlos@iexpertos.com>


¿Cómo podemos saber si el código que estamos escribiendo es bueno o malo? Todavía no existe ningún método preciso que determine si un software es de buena calidad. Sólo el paso del tiempo puede confirmarlo, baśandose en cuatro parámetros fundamentales:
- Nivel de aceptación del usuario: El software se comporta como desea quien lo necesita.
- Cantidad de defectos (bugs) que llegan al usuario
- Legibilidad: Cuánto cuesta entender el código.
- Extensibilidad: Cúanto cuesta introducir cambios.

La experiencia de escribir código y tenerlo que mantener es muy valiosa porque nos muestra el impacto de nuestras decisiones de diseño en el medio y largo plazo, lo que nos permite aprender. Si nos enfrentamos a un mismo problema por segunda vez, la experiencia nos llevará a escribir una solución mejor que la primera. La pega es que nadie tiene experiencia resolviendo la totalidad de los problemas que se presentan, así que, la usamos de manera heurística comparando problemas actuales con problemas del pasado. Cuando detectamos una implementación que se parece a otra que resultó perjudicial, solemos hablar de un «mal olor» (code smell en inglés).

Los olores del código siguen sin confirmarnos que nuestro trabajo es de la calidad deseada pero sí ayudan a detectar, desde una fase temprana, el problemático.
Existen reglas para detectar malas prácticas en términos de los cuatro parámetros citados anteriormente. Las más importantes son:

- No debe existir código duplicado.
- Hay que nombrar todo lo que es nombrable, evitando por tanto los números y cadenas literales desperdigados.
- Los nombres deben ser autoexplicativos, conteniendo la semántica del dominio y sin detalles técnicos de implementación.

Además de estas, cuando trabajamos dentro del paradigma de la orientación a objetos, utilizamos los principios de diseño SOLID  <<BLEYCO>> y el principio de la encapsulación.

La dificultad de las reglas es que no son matemáticas. No podemos dárselas a una Máquina de Turing (cualquier computadora de hoy en día) para que detecte todas las infracciones, salvo en casos muy sencillos y evidentes, para lo cual existen herramientas de análisis que en ocasiones aciertan en su veredicto.

Un mismo bloque de código podría estar violando varias reglas, mientras que la aplicabilidad de otras podría ser nula. No es fácil ni directo saber cuándo estamos perjudicando el ciclo de vida del software.

En este artículo trataré de presentar ejemplos acotados con la finalidad de ayudar al lector a desarrollar el olfato de diseñador, utilizando la orientación a objetos. Los ejemplos están escritos en un pséudo-código mezcla de Python, C# y Javascript, donde los métodos se definen con la palabra reservada «def». Los puntos suspensivos significan una o más líneas de código cualesquiera.

Ausencia de encapsulación
-------------------------
La encapsulación es uno de los pilares de la orientación a objetos. Un objeto no debe conocer la implementación de otro, es decir, no debe conocer lo que el otro tiene por dentro sino sólo su interfaz pública (sus métodos públicos). Los malos olores respecto a la encapsulación suelen aparecer cuando se accede a más de un atributo del objeto en la misma operación:

[source,python]
----------------------------------
class SalesService:
  def is_valid_promotion(promotion):
      return promotion.dead_line > today() and
             promotion.is_active
----------------------------------

El problema de este bloque es que el conocimiento sobre la validez de la promoción está en el servicio de ventas. Sabe cómo funciona una promoción por dentro. El refactoring «move method» <<Fowler99>> nos permite cumplir con la encapsulación:

[source,python]
---------------------------
class Promotion:
     var dead_line, is_active

     def is_valid_until(date):
         return dead_line > date and is_active
---------------------------

No sólo hemos redistribuido las responsabilidades a donde corresponden sino que ha quedado parametrizado para cualquier fecha, es decir, es más extensible. Nótese que también hemos renombrado el método para reflejar la semántica y le hemos quitado la palabra +promotion+ porque ya está en la clase. Además estamos facilitando la labor de escribir tests unitarios al código porque la obtención de fecha ya no es responsabilidad de la promoción y ello permite probar con varias y hacer simulaciones.

Es muy común observar este patrón cuando se usan objetos de transferencia de datos (DTOs) y se intenta validar la integridad de los datos de entrada.

[source,python]
---------------------------
class SalesService:
      def sale(article):
          if article.id < 0 or article.category is null:
             return
          ...
---------------------------

Lo adecuado en este caso podría ser dotar al objeto artículo de la capacidad de saberse válido:

[source,python]
---------------------------
class Article:
      var id, category

      def is_invalid():
          return not(is_valid())

      def is_valid():
          return article.id >= 0 and article.category is not null:

class SalesService:
      def sale(article):
          if article.is_invalid():
             return
          ...
---------------------------

Cuando un método de tipo +boolean+ va a consumirse usando la negación,
es preferible incluirla en el nombre del método en vez de preceder la llamada de operadores de negación. En el ejemplo de arriba, utilizamos el método +is_invalid+ porque es más legible que:

[source,python]
---------------------
if not(article.is_valid())
---------------------

especialmente cuando combinamos los operadores lógicos +and+ y +or+.

Extraer comportamiento a un método no sólo facilita la legibilidad y la mantenibilidad, sino que además, ayuda a pensar en la responsabilidad del método y del objeto. Si el día de mañana consideramos oportuno trasladar el comportamien a otra clase, será más intuitivo y rápido de hacer.

Un método no debe tener más de dos parámetros, a los sumo tres. Este consejo nos puede ayudar a identificar posibles objetos que quieren emerger de refactor. Podriamos habernos encontrado el ejemplo anterior así:

[source,python]
---------------------------
class SalesService:
      def sale(id, category, amount, name):
          if id < 0 or category is null:
             return
          ...
---------------------------

Conceptualmente sabemos que estamos trabajando con atributos o cualidades de un artículo, por tanto lo mejor es encapsular estos atributos en un objeto artículo como el del ejemplo anterior.


Construcción y configuración de objetos
---------------------------------------
El paradigma de la orientación a objetos se basa en metáforas, se asocian comportamientos con artefactos software. Parecido a como hacemos las personas para asimilar cierta información. Generalmente la relación directa entre objetos de nuestro entorno y objetos software no existe. Porque el código debe expresar comportamiento, acciones, no estructuras de datos. O séa que un objeto software puede expresar un comportamiento de un objeto real, pero no todos sus aspectos en todas las circunstancias. Cuando se pretenden modelar objetos del mundo real con un lenguaje de programación, haciendo un diseño previo a la implementación, es fácil cometer el error de querer plasmar en una clase todos los aspectos del objeto real. Eso provoca clases con más de una responsabilidad y por tanto, con problemas de mantenimiento.

La idea no es implementar un objeto por cada concepto del dominio de la solución, sino prestar atención a las metáforas más llamativas de los objetos cotidianos. Pensar qué pueden aportarnos a grandes rasgos cuando diseñamos.

Modelar soluciones es muy difícil de hacer a priori, pero existen técnicas como Test Driven Development que permiten hacerlo de manera orgánica.

Pongamos ejemplos de metáforas con información valiosa, hablemos de automóviles:

Un objeto complejo como un coche, no se construye por sí mismo en el mundo real. Los coches se generan en factorías, son construidos por personas y robots. Esto no significa que, dado un escenario concreto, no podamos modelar su creación con un constructor por defecto:

[source,python]
---------------------
var car = new Car()
---------------------

Pero debemos observar que los objetos complejos no tienen por qué ser responsables de su propia construcción. O sea que probablemente conviene delegar la construcción en una factoría:

[source,python]
---------------------
var car = Factory.Car()
---------------------

Si el primer objeto que decidimos crear es el coche, no podremos saber si instanciarlo directamente o pedirlo a una factoría. Pero conforme vamos aumentando el número de objetos y las líneas de código de su implementación, sí podemos "olfatear" y tomar decisiones.

Un objeto que necesita recibir parámetros en su constructor, está pidiendo una factoría especialista que se encargue de construirle:

[source,python]
---------------------------
var service = Factory.SalesService()

class SalesService:
      var repository, validator

      def constructor(repository, validator):
          this.repository = repository
          this.validator = validator

static class Factory:
      def SalesService():
          return SalesService(new SalesRepository(),
                              new SalesValidator())
---------------------------

Para crear el servicio de ventas, se require un repositorio de ventas y un validador. El servicio recibe sus dependencias a través del constructor para que la factoría las gestione y devuelva una instancia correctamente ensamblada.

Lo que conseguimos de esta manera es que si más adelante se necesita una tercera dependencia o se quita alguna de las que tiene, no habrá que modificar código más que en un sitio. Además el consumidor del servicio, no tiene por qué conocer todo lo que hace falta para ensamblarlo, lo que nos lleva de vuelta a una correcta encapsulación.

En determinadas circunstancias las dependencias de un objeto se inyectan por «setters» y son los frameworks de «IoC» (Inversion of Control) quienes ensamblan el objeto por nosotros. Pero conceptualmente no dejan de ser una factoría. Es bueno reconocerlo porque a veces se utilizan frameworks complejos como Spring cuando sólo se necesita una factoría sencilla como la del ejemplo anterior.

Que las dependencias se inyecten por constructor o por setter, es circunstancial, depende del framework que se use. Lo importante es tener claro que ambas técnicas resuelven la configuración del objeto. A estas dependencias que son también objetos, se les llama colaboradores.

Inyectar parámetros de configuración que no son colaboradores, es un mal olor dependiendo desde dónde se haga. Es decir, si para crear un objeto tengo que enviarle una cadena de conexión a base de datos, una contraseña, o una variable de configuración de la aplicación, probablemente estoy ante un mal diseño. Porque significa que hay que conocer demasiados detalles internos del objeto y volvemos a fallar con la encapsulación. Una solución es inyectar un colaborador que encapsula estos parámetos y que tiene una API simplificada a la que nuestro objeto puede consultar. La otra es volver a recurrir a la factoría, ya que al menos, ese conocimiento tan detallado sólo estará en un lugar.

El constructor de una clase, tenga o no tenga parámetros, no debe realizar acciones de ningún tipo sino limitarse a conectar sus colaboradores. Los setters tampoco. Es decir, al construir el objeto no se debe ejecutar ningún otro método. Hay varios motivos para esta regla. El primero es que quien invoque a ese constructor o incluso a la factoría, seguramente espera que la generación de una nueva instancia sea inócua. No espera que el estado del sistema pueda alterarse por el mero hecho de obtener una nueva instancia.

Ejemplo: un «widget» cuya misión es mostrar en la interfaz gráfica una lista desplegable de opciones. Nos llevaríamos una sorpresa si al obtener una instancia del objeto, éste invoca a su método +render+ y lo dibuja. Es preferible que se dibuje bajo demanda.

Existen más motivos para que las construcciones sean inofensivas. Uno es que en determinados lenguajes, las excepciones que se producen en tiempo de ejecución dentro de un constructor, generan mensajes de error inhumanos. El otro es que se dificulta la labor de escribir tests automáticos ya que no podemos reemplazar métodos con dobles antes de que el objeto se llegue a crear.

Gestión inadecuada de dependencias
----------------------------------
Los fallos en cadena se suelen producir por una gestión inadecuada de dependencias. El principio de inyección de dependencias dice que deben inyectarse a quien las requiere y no al revés. El siguiente código viola el principio porque decide explícitamente quienes son sus colaboradores:

[source,python]
---------------------------
class SalesService:
        var repository, validator

    def constructor():
        this.repository = new SalesRepository()
        this.validator = new SalesValidator()
---------------------------

Escrito así, perdemos el puerto de conexión y desconexión de dependencias. En la versión anterior del servicio de ventas sí que se cumplía el principio, ya que se inyectaban las instancias por constructor.
Más allá de la inversión del control (inyección de dependencias), hay otras reglas que tener en cuenta.
Si consideramos que los objetos de la interfaz de usuario constituyen la capa de arriba y el acceso a base de datos la capa de abajo, decimos que un objeto de nivel inferior, nunca debe depender de otro de nivel superior. Sólo los objetos de alto nivel pueden depender de objetos de bajo nivel.
Ejemplo: El servicio de ventas no puede depender de un «widget» de la GUI. Será el objeto que consume el servicio de ventas, quien se encargue de extraer la información de la interfaz de usuario y hacersela llegar, libre de cargas innecesarias.
La capa N sólo tendrá dependencias en N -1 y nunca al revés.
El objetivo es que no se produzcan acoples innecesarios.

Por otra parte, los grafos de dependencias, también huelen mal. Si el objeto +X+ depende de +H+ y este a su vez depende de +Z+, todo va bien. Pero si +Z+ depende de +X+, o viceversa, habremos cerrado el grafo, habremos hecho cortocircuito. Los ciclos son problemáticos porque denotan gestión inadecuada de responsabilidades. Para romperlos hay varios refactorings: mover métodos entre clases para acomodarlos donde tienen más sentido (según la misión de la clase y la acción que lleva a cabo el método), crear clases nuevas a partir de existentes, o fusionarlas.
Los ciclos que se diseñan a conciencia, sin que ocurran por accidente, no son necesariamente problemáticos cuando el ciclo sólo tiene dos objetos. Por ejemplo, si X pide información a H de manera asíncrona y H se comunica con X para avisarle de que ya terminó, no tiene por qué haber problemas de dependencias.

Nombres inadecuados
-------------------
Los nombres que ponemos a las variables, a los métodos, a las clases y a los paquetes, no deben ser demasiado abstractos ni demasiado concretos.

Ejemplos de sufijos y prefijos demasiado abstractos:
+Helper+, +Generic+, +Tools+, +Utils+, +Manager+, +Gestor+, +Abstract+, +Impl+, +I+, +My+, +Get+, +Set+.

Ejemplos de nombres que incluyen estos comodines:
+MyCar+, +GenericService+, +SalesUtils+, +CarImpl+, +ICar+, etc...

Usar este tipo de comodines significa no comprometerse con el código que se está escribiendo. Al fin y al cabo todo son «Utils» y «Tools», como el software mismo. Es información redundante que no aporta valor. Quien consume un objeto no tiene más ayuda por leer el sufijo +Impl+ o el prefijo +I+. Es mero descuido del que eligió el nombre de ese artefacto. Hay que pensar que el código lo escribimos para otras personas, no para las máquinas. Las máquinas tragan código binario y no entienden de nombres. El hecho de que la API del framework Microsoft .Net incluya el prefijo +I+ para las interfaces, no lo convierte en una buena práctica, aunque en algún caso puede tener sentido siendo un framework base y genérico (horizontal), pero desde luego en el desarrollo de soluciones de negocio (verticales) no aporta ningún valor.
Si nos encontramos con la dificultad de no saber qué nombre poner a una interfaz para que no sea idéntico a la clase que la implementa, seguramente es que no hace falta crear una interfaz. Una clase ya es en sí misma una interfaz, pero con implementación. Si la escribimos bien se puede extender y reimplementar, sin necesidad de definir interfaces vacías. En otros lenguajes como Python o Ruby ni siquiera existe el concepto de interfaz sin implementación. El consejo de usar interfaces para las dependencias en lugar de implementaciones concretas, está muy extendido pero también está mal entendido. Lo que realmente quiere decir es que respetemos la encapsulación, evitando asumir que esa dependencia tiene por dentro detalles que no están en su interfaz.

El lado opuesto de los nombres demasiado abstractos es el de los nombres que tienen más información de la que se necesita:
+GetNameString+, +ThrowExceptionIfEmpty+, +ValidateAndSave+, ...

En los nombres de variables y métodos no deben aparecer tipos de datos. Considerando que deben expresar el lenguaje del dominio del problema, palabras como +String+ o +Boolean+ no aportan nada. Los entornos de desarrollo permiten saber fácilmente cuál es el tipo de dato devuelto por un método si lo necesitamos en algún momento. En cuanto a describir la implementación de un método en su nombre, el problema es que, si le cambiamos algún detalle, podría quedar nombre obsoleto. Hay que pensar qué responsabilidad tiene el método y nombrarlo en función a ella, en lugar de contar qué es lo que hace. Así el método +ThrowExceptionIfEmpty+ podría llamarse +AssertValidInput+ tal que en el futuro si decidimos que las reglas de validación cambian, el nombre del método sigue siendo apropiado.

Comportamiento configurable según base de datos
-----------------------------------------------
A veces queremos cambiar el comportamiento de la aplicación dependiendo del rol del usuario o de cualquier otra circunstancia, de manera dinámica, sin hacer cambios en el código. Por ejemplo mostrar determinados elementos del menú de la interfaz de usuario según la configuración de permisos, renderizar una aplicación web según el dispositivo que la consume, etc. Y existe la tentación de que sea la base de datos y/o un fichero de configuración, quien contenga todo el conocimiento referente a los cambios de comportamiento. El gran problema es que ni una base de datos relacional ni un fichero de configuración, pueden expresar comportamiento con la claridad que lo hacen los objetos. La estructura tabular de una base de datos SQL no soporta el modelado de las ideas humanas. Si partimos de tablas, el código fuente que conecta comportamiento con la base de datos, será muy dificil de entender y por tanto de mantener, ya que nos fuerza a pensar de una manera que no es natural. Incluso para dotar de distinto comportamiento la aplicación, es decir, para introducir una nueva configuración, hay que ser todo un experto manipulando columnas y tablas. Por si fuera poco, la automatización de pruebas se hace casi imposible.
Mediante inyección de dependencias hacemos que la aplicación cambie de comportamiento dinámicamente sin que la configuración sea infernal.
Ejemplo: para mostrar diferentes elementos de menú según el rol del usuario, podemos tener un objeto que sabe qué elementos debe mostrarle. Ese objeto se configurará o no, con colaboradores. Podemos usar herencia o composición. Supongamos que elegimos una jerarquía de clases donde la base muestra todos los elementos de menú. Luego hay clases que la extienden y dejan de mostrar ciertas acciones según el permiso:

[source, python]
---------------------------
class ActionsMenu:
      ...

class AdminActionsMenu: ActionsMenu
      ...

class GuestActionsMenu: ActionsMenu
      ...
---------------------------

Cuando el usuario entra al sistema con sus credenciales, una factoría puede construir la clase de manejo del menú correspondiente a sus permisos. Si no hace falta añadir entradas al menú de manera dinámica durante la ejecución, las opciones del menú podrían estar incluso escritas en el código del objeto que maneja el menú (hardcoded). De esta manera tendriamos que generar distintas versiones de la aplicación para tener nuevas opciones en el menú. Para más potencia, podemos intercalar un framework de inyección de dependencias que nos permita indicar en un fichero xml qué clases queremos que inyecte según el entorno.
Si esta opción no conviene, podemos apoyarnos en otros ficheros de configuración o base de datos, asumiendo un coste de complejidad adicional en el proceso de despliegue y también la posibilidad de introducir defectos al editar la configuración.

Mientras estamos dentro de los límites de nuestro código, podemos añadir tests automaticos hasta cubrir el 100% de los casos (practicar Test-first). Nos podemos hacer entender en el lenguaje del dominio y añadir cambios con agilidad.

Cuando la potencia del código fuente sea insuficiente, podremos recurrir a los soportes externos pero con consciencia de las ventajas y los inconvenientes que suponen.


Abuso de la herencia
--------------------
Existe la creencia de que si todas las clases de un paquete pertenecen a una misma jerarquía, el código es más homogéneo. Que sea homogéneo o no, incluso sin entrar a definir qué consideramos por homogéneo, no aporta valor. Lo que importa es la mantenibilidad del código, la cual se favorece cuando aplicamos principios de diseño como SOLID. Es más probable que un buen diseño contenga composición que herencia. Por eso hay una frase célebre que dice, "favorece la composición sobre la herencia". Quiere decir que suele ser más conveniente componer una clase, inyectando clases colaboradoras, que crear una jerarquía que las contiene a todas.
La decisión de que una clase hereda de otra no debe ser tomada cuando aún no existe. Usamos herencia cuando ambas existen y tienen código duplicado de tal forma que, para extraer factor común, lo mejor es jerarquizar. Hay muchas formas de duplicidad, la que nos lleva a aplicar herencia es la duplicidad de comportamiento, o sea, cuando queda claro que ambas clases se están comportando casi igual, salvo algún matiz diferenciador.
Por regla general la clase hija redefine algún método de los que hereda para expresar tal matiz. Hay varias formas de implementar una jerarquía. Tipicamente se abusa de las clases abstractas. Una clase abstracta sólo se necesita cuando es la única manera de sacar factor común. Al poner en una clase el código común, si se ve que dicha clase no tiene una implementación por defecto suficiente como para ser consumida por otras, entonces se decide que es abstracta, para que no puedan haber instancias de una clase que está a medias. Pasa sobre todo con algoritmos. La clase abstracta incluye el grueso del algoritmo pero delega una o más partes en sus clases hijas. Es decir, el algoritmo contiene alguna llamada a un método protegido de la clase que está sin implementar y que debe ser implementado por quienes heredan. Este es el patrón de diseño "Template method". Si resulta que hay una implementación por defecto de ese método protegido, que nos vale, entonces la clase no tiene por qué ser abstracta, simplemente define el método como protegido para que pueda ser redefinido en clases hijas. En algunos lenguajes como C# debemos usar la palabra reservada +virtual+ en la clase base y +override+ en la clase hija.
Diseñar jerarquías a priori es tremendamente difícil y muy propenso al sobrediseño, a un exceso de complejidad que termina por introducir problemas de mantenimiento.
El hecho de que dos clases tengan el mismo prefijo en el nombre no significa que tengan el mismo comportamiento. No es el argumento que justifica la jerarquía. Puede que el prefijo quede muy bien en el espacio de nombres ("namespace") del paquete y no en las clases.
Los objetos no se inventaron para modelar una estructura de directorios o de paquetes sino para modelar un comportamiento mucho más humano.
Cuando dos clases trabajan conjuntamente pero su comportamiento es diferente (y disjunto) la manera de conectarlas es componer una con la otra mediante inyección de la dependencia.
El código de calidad está escrito para que otras personas lo entiendan e incluso para que entiendan cómo pensaba la persona que lo escribió cuando lo hizo.


La sutileza de Liskov
---------------------
El principio de sustitución de Liskov viene a decir de manera sutíl, que debemos considerar los objetos como cajas negras, sin conocer más que su interfaz pública. La forma en que típicamente incumplimos el principio es preguntando si el objeto que estamos manejando es, presuntamente, de un subtipo concreto. Una vez que asumimos que es la implementación concreta X de la interfaz Y, le damos un trato exclusivo en función de las propiedades de X que no están en Y.

[source, python]
---------------------------
def render(menu):
    if typeOf(menu) is AdminActionsMenu:
       ...
    else if typeOf(menu) is GuestActionsMenu:
       ...
---------------------------

El problema con este enfoque es que quien consume el método +render+ tiene que saber cómo funciona por dentro. Si le invoca pensando que funcionará con cualquier implementación de +ActionsMenu+, se llevará una decepción, a pesar de que es lo que su firma dice. Nótese que este es un ejemplo de código sacado de contexto, tal vez en otro contexto el método +render+ pertenece al menú en sí mismo.
Otra forma de romper el principio es usando conversión de tipos («typecast») porque de la misma manera preparan el terreno para consumir el objeto según sus detalles concretos. Una solución para poder generalizar tipos en clases que tienen dependencias, es el uso de genéricos (Java y C#). La generalización, al igual que la jerarquización, debe producirse como consecuencia de la eliminación de duplicidad:

[source,csharp]
---------------------------
public abstract class FruitsController<Service>{
    protected Service service;

    protected abstract List<string> Find(string farmName);

    public List<string> FindByFarm(string input){
         input = input.ToLower();
         return Find(input);
    }
}

public class ApplesController<ApplesService>{
    protected override List<string> Find(string farmName){
         return service.FindApples(farmName);
    }
}

public class BananasController<BananasService>{
    protected override List<string> Find(string farmName){
         return service.FindBananas(farmName);
    }
}
---------------------------

En lenguajes dinámicos como Python, Ruby o Javascript, prefiero el
"ducktyping" a preguntar por tipos concretos. Ducktyping quiere decir
que si un objeto tiene la API que necesito consumir, me da igual el tipo
que tenga. Me basta con preguntar si tiene tal o cual método. Algunos
de los problemas que existen en Javascript con los tipos, podrían evitarse
si el diseño cumple con el principio de Liskov (si es que estamos usando Javascript con orientación a objetos, ya que este lenguaje también puede usarse con el paradigma funcional).


Mezcla de paradigmas
--------------------
Los paradigmas de programación son una forma de pensar. Una forma de afrontar la solución a un problema. Hay problemas cuya solución es más elegante con el paradigma orientado a objetos que con el funcional y viceversa. Además hay otros paradigmas. Los lenguajes y plataformas que soportan ambos paradigmas son muy interesantes porque nos permiten conectar soluciones parciales para ofrecer un mejor producto global. Sin embargo, mezclar distintos paradigmas en la misma solución supone un nivel de complejidad demasiado caro. Esto se ve frecuentemente cuando se intenta programar orientado a objetos y sin embargo hay un punto en el que se pasa como argumento de un método, una función. En lenguajes como C# es posible gracias a las funciones anónimas. En lenguajes dinámicos como Python, Ruby o Javascript, es tremendamente fácil hacerlo. Pero posible no significa adecuado. Si los parámetros de nuestras funciones son otras funciones, no hay encapsulación ni objetos por ninguna parte. En ese caso estamos hablando de programación funcional. Se puede implementar el mismo algoritmo con orientación a objetos, si pasamos por parámetro objetos de una determinadad interfaz. Algunos patrones de diseño como el «Command» se basan en esta técnica.
Recuerdo que para aprender a programar en Lisp tuve que entrenar mi cerebro hasta que consiguió pensar de manera diferente y llevó su tiempo. Luego me costaba volver a los ojetos y no usar la recursividad antes que el bucle. Claramente son dos enfoques complementarios pero su mezcla puede resultar explosiva.

Conclusión
----------
El olfato desarrollado para los olores del código es desde mi punto de vista una cualidad del artesano de software. Hablamos de artesanía porque desconocemos todas las variables que lo convertirían en ingeniería.
El reto de descubrir mejores formas de diseñar software cada día, hace nuestra profesión apasionante. Nadie debe desanimarse por no poder ver la mejora o por descubrir que el código que escribió hace tiempo es mejorable. Debe alegrarse de reconocerlo y si se anima, ayudar a otros a mejorar.
El software nunca es perfecto, es una expresión del conocimiento humano y como tal, muta.

Este capítulo no puede terminarse sin que recomiende el estudio del libro "Clean Code" de Robert C. Martin, que es una de las guías más completas que se han escrito sobre código limpio.

[bibliography]
Bibliografía
------------
- [[[BLEYCO]]] Carlos Blé y colaboradores 'Diseño Agil con TDD' iExpertos.com. ISBN 978-1-4452-6471-4.
http://www.dirigidoportests.com/el-libro
- [[[Fowler99]]] Martin Fowler 'Refactoring, improving the design of existing code' Addison-Wesley Professional. ISBN 978-0201485677.
http://martinfowler.com/books.html#refactoring
