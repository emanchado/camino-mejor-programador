¿Cómo podemos saber si el código que estamos escribiendo es bueno o malo? Todavía no existe ningún método preciso que determine si un software es de buena calidad. Sólo el paso del tiempo puede confirmarlo, baśandose en cuatro parámetros fundamentales: 
- Nivel de aceptación del usuario: El software se comporta como desea quien lo necesita. 
- Cantidad de defectos (bugs) que llegan al usuario
- Legibilidad: Cuánto cuesta entender el código.
- Extensibilidad: Cúanto cuesta introducir cambios.

La experiencia de escribir código y tenerlo que mantener es muy valiosa porque nos muestra el impacto de nuestras decisiones de diseño en el medio y largo plazo, lo que nos permite aprender. Si nos enfrentamos a un mismo problema por segunda vez, la experiencia nos llevará a escribir una solución mejor que la primera. La pega es que nadie tiene experiencia resolviendo la totalidad de los problemas que se presentan, así que, la usamos de manera heurística comparando problemas actuales con problemas del pasado. Cuando detectamos una implementación que se parece a otra que resultó perjudicial, solemos hablar de un "mal olor" (code smell en inglés).
Los olores del código siguen sin confirmarnos que nuestro trabajo es de la calidad deseada pero sí ayudan a detectar, desde una fase temprana, el problemático. 
Existen reglas para detectar malas prácticas en términos de los cuatro parámetros citados anteriormente. Las más importantes son:

- No debe existir código duplicado.
- Hay que nombrar todo lo que es nombrable, evitando por tanto los números y cadenas literales desperdigados.
- Los nombres deben ser autoexplicativos, conteniendo la semántica del dominio y sin detalles técnicos de implementación.

Además de estas, cuando trabajamos dentro del paradigma de la orientación a objetos, utilizamos los principios de diseño SOLID  [CarlosBle2010] y el principio de la encapsulación.    

La dificultad de las reglas es que no son matemáticas. No podemos darselas a una Máquina de Turing (cualquier computadora de hoy en día) para que detecte todas las infracciones, salvo en casos muy sencillos y evidentes, para lo cual existen herramientas de análisis que en ocasiones aciertan en su veredicto.

Un mismo bloque de código podría estar violando varias reglas, mientras que la aplicabilidad de otras podría ser nula. No es fácil ni directo saber cuándo estamos perjudicando el ciclo de vida del software.

En este artículo trataré de presentar ejemplos acotados con la finalidad de ayudar al lector a desarrollar el olfato de diseñador,  
utilizando la orientación a objetos. Los ejemplos están escritos en un pséudo-código mezcla de Python y C#, donde los métodos se definen con la palabra reservada "def". Los puntos suspensivos significan una o más líneas de código cualesquiera. 

- Ausencia de encapsulación:
La encapsulación es uno de los pilares de la orientación a objetos. Un objeto no debe conocer la implementación de otro, es decir, no debe conocer lo que el otro tiene por dentro sino sólo su interfaz pública (sus métodos públicos). Los malos olores respecto a la encapsulación suelen aparecer cuando se accede a más de un atributo del objeto en la misma operación:

   class SalesService:
     def is_valid_promotion(promotion):
         return promotion.dead_line > today() and 
                promotion.is_active

El problema de este bloque es que el conocimiento sobre la validez de la promoción está en el servicio de ventas. Sabe cómo funciona una promoción por dentro. El refactoring "move method" [Fowler99] nos permite cumplir con la encapsulación:

     class Promotion:
          var dead_line, is_active

          def is_valid_until(date):
              return dead_line > date and is_active

No sólo hemos redistribuido las responsabilidades a donde corresponden sino que ha quedado parametrizado para cualquier fecha, es decir, es más extensible. Nótese que también hemos renombrado el método para reflejar la semántica y le hemos quitado la palabra "promotion" porque ya está en la clase. Además estamos facilitando la labor de escribir tests unitarios al código porque la obtención de fecha ya no es responsabilidad de la promoción y ello permite probar con varias y hacer simulaciones. 

Es muy común observar este patrón cuando se usan objetos de transferencia de datos (DTOs) y se intenta validar la integridad de los datos de entrada. 
     
     class SalesService:
           def sale(article):
               if article.id < 0 or article.category is null:
                  return 
               ... 
                
Lo adecuado en este caso es dotar al objeto artículo de la capacidad de saberse válido:

     class Article:
           var id, category

           def is_invalid():
               return not(is_valid())

           def is_valid():
               return article.id >= 0 and article.category is not null:
                  
     class SalesService:
           def sale(article):
               if article.is_invalid():
                  return 
               ... 

Cuando un método de tipo boolean va a consumirse usando la negación,
es preferible incluirla en el nombre del método en vez de preceder la llamada de operadores de negación. En el ejemplo de arriba, utilizamos el método "is_invalid" porque es más legible que:
    if not(article.is_valid()) 
especialmente cuando combinamos los operadores lógicos "and" y "or".
Extraer comportamiento a un método no sólo facilita la legibilidad y la mantenibilidad, sino que además, ayuda a pensar en la responsabilidad del método y del objeto. Si el día de mañana consideramos oportuno trasladar el comportamien a otra clase, será más intuitivo y rápido de hacer.

Un método no debe tener más de dos parámetros, a los sumo tres. Este consejo nos puede ayudar a identificar posibles objetos que quieren emerger de refactor. Podriamos habernos encontrado el ejemplo anterior así:

     class SalesService:
           def sale(id, category, amount, name):
               if id < 0 or category is null:
                  return 
               ...

Conceptualmente sabemos que estamos trabajando con atributos o cualidades de un artículo, por tanto lo mejor es encapsular estos atributos en un objeto.


- Construcción y configuración de objetos:
El paradigma de la orientación a objetos se basa en metáforas, asociando conceptos con objetos, como hacemos las personas para asimilar cierta información. Generalmente es un error pensar que la relación entre objetos cotidianos y objetos codificados es trivial o directa. La idea no es implementar un objeto por cada concepto del dominio de la solución, sino prestar atención a las metáforas más llamativas de los objetos cotidianos. Pensar qué pueden aportarnos a grandes rasgos cuando diseñamos. 
Modelar soluciones es muy difícil de hacer a priori, pero existen técnias como Test Driven Development que permiten hacerlo de manera orgánica, si somos capaces de filtrar la información relevante.  
Pongamos ejemplos de metáforas con información valiosa, hablemos de automóviles: 
Un objeto complejo como un coche, no se construye por sí mismo en el mundo real. Los coches se generan en factorías, son construidos por personas y robots. Esto no significa que, dado un escenario concreto, no podamos modelar su creación con un constructor por defecto:
       
      var car = new Car()

Pero debemos observar que los objetos complejos no tienen por qué ser responsables de su propia construcción. O sea que probablemente conviene más delegar la construcción en una factoría:

      var car = Factory.Car()

Si el primer objeto que decidimos crear es el coche, no podremos saber si crearlo directamente o pedirlo a una factoría. Pero conforme vamos aumentando el número de objetos y las líneas de código de su implementación, sí podemos "olfatear" y tomar decisiones.
Un objeto que necesita recibir parámetros en su constructor, está pidiendo una factoría especialista que se encargue de construirle:

      var service = Factory.SalesService()

      class SalesService:
            var repository, validator

            def constructor(repository, validator):
                this.repository = repository
                this.validator = validator

      static class Factory:
            def SalesService():
                return SalesService(new SalesRepository(), 
                                    new SalesValidator())   

Para crear el servicio de ventas, se require un repositorio de ventas y un validador. El servicio recibe sus dependencias a través del constructor para que la factoría las gestione y nos devuelva una instancia correctamente ensamblada.
Lo que conseguimos de esta manera es que si más adelante se necesita una tercera dependencia o se quita alguna de las que tiene, no habrá que modificar código más que en un sitio. Además el consumidor del servicio, no tiene por qué conocer todo lo que hace falta para ensamblarlo, lo que nos lleva de vuelta a una correcta encapsulación.
En determinadas circunstancias las dependencias de un objeto se inyectan por "setters" y son los frameworks de IoC (Inversion of Control) quienes ensamblan el objeto por nosotros. Pero conceptualmente no dejan de ser una factoría. Es bueno reconocerlo porque a veces se utilizan frameworks complejos como Spring cuando sólo se necesita una factoría sencilla como la del ejemplo anterior.
Que las dependencias se inyecten por construcstor o por setters, es circunstancial, depende del framework que se use. Lo importante es tener claro que ambas técnicas resuelven la configuración del objeto. A estas dependencias que son también objetos, se les llama colaboradores.

Inyectar parámetros de configuración que no son colaboradores, es un mal olor dependiendo desde dónde se haga. Es decir, si para crear un objeto tengo que enviarle una cadena de conexión a base de datos, una contraseña, o una variable de configuración de la aplicación, probablemente estoy ante un mal diseño. Porque significa que hay que conocer demasiados detalles internos del objeto y volvemos a fallar con la encapsulación. Una solución es inyectar un colaborador que encapsula estos parámetos y que tiene una API simplificada a la que nuestro objeto puede consultar. La otra es volver a recurrir a la factoría, ya que al menos, ese conocimiento tan detallado sólo estará en un lugar.    

El constructor de una clase, tenga o no tenga parámetros, no debe realizar acciones de ningún tipo sino limitarse a conectar sus colaboradores. Los setters tampoco. Es decir, al construir el objeto no se debe ejecutar ningún otro método. Hay varios motivos para ello. El primero es que quien invoque a ese constructor o incluso a la factoría, seguramente espera que la generación de una nueva instancia sea inócua. No espera que el estado del sistema pueda alterarse por el mero hecho de obtener una nueva instancia. 
Ejemplo: un widget cuya misión es mostrar en la interfaz gráfica una lista desplegable de opciones. Nos llevaríamos una sorpresa si al obtener una instancia del objeto, éste invoca a su método "render" y lo dibuja. Es preferible que se dibuje bajo demanda.
Existen más motivos para que las construcciones sean inofensivas. Uno es que en determinados lenguajes, las excepciones que se producen en tiempo de ejecución dentro de un constructor, generan unos mensajes de error inhumanos. El otro es que se dificulta la labor de escribir tests automáticos ya que no podemos reemplazar métodos con dobles antes de que el objeto se llegue a crear. 

- Gestión inadecuada de dependencias:
Los fallos en cadena se suelen producir por una gestión inadecuada de dependencias. El principio de inyección de dependencias dice que deben inyectarse a quien las requiere y no al revés. El siguiente código viola el principio porque decide explícitamente quienes son sus colaboradores:

      class SalesService:
              var repository, validator

          def constructor():
              this.repository = new SalesRepository()
              this.validator = new SalesValidator()

Escrito así, perdemos el punto de conexión y desconexión de dependencias que simplifica muchísimo su gestión. En la versión anterior del servicio de ventas sí que se cumplía el principio, ya que se inyectaban las instancias por constructor.
Más allá de la inversión del control (inyección de dependencias), hay otras reglas que tener en cuenta.
Si consideramos que los objetos de la interfaz de usuario constituyen la capa de arriba y el acceso a base de datos la capa de abajo, decimos que un objeto de nivel inferior, nunca debe depender de otro de nivel superior. Sólo los objetos de más alto nivel pueden depender de objetos de bajo nivel. 
Ejemplo: El servicio de ventas no puede depender de un widget de la GUI. Será el objeto que consume el servicio de ventas, quien se encargue de extraer la información de la interfaz de usuario y hacersela llegar, libre de cargas innecesarias.
La capa N sólo tendrá dependencias en N -1 y nunca al revés.
El objetivo es que no se produzcan acoples donde no corresponde.

Por otra parte, los grafos de dependencias, también huelen mal. Si el objeto X depende de H y este a su vez depende de Z, todo va bien. Pero si Z depende de X, o viceversa, habremos cerrado el grafo, habremos hecho corto circuito. Los ciclos son problemáticos porque denotan gestión inadecuada de responsabilidades. Para romperlos hay varios refactorings: mover métodos entre clases para acomodarlos donde tienen más sentido (según la misión de la clase y la acción que lleva a cabo el método), crear clases nuevas a partir de existentes, o unirlas.
Los ciclos que se diseñan a conciencia, sin que ocurran por accidente, no son necesariamente problemáticos cuando el ciclo sólo tiene dos objetos y cuando además se diseña como parte de un flujo de trabajo. Es decir, si X pide información a H de manera asíncrona y H se comunica con X para avisarle de que ya terminó, no tiene por qué haber problemas si la comunicación se implementa debidamente.

- Nombres inadecuados:
Los nombres que ponemos a las variables, los métodos, las clases y los paquetes, no deben ser demasiado abstractos ni demasiado concretos.
Ejemplos de sufijos y prefijos demasiado abstractos:
Helper, Generic, Tools, Utils, Manager, Gestor, Abstract, Impl, I, My, Get, Set.
Ejemplos de nombres que incluyen estos comodines:
MyCar, GenericService, SalesUtils, CarImpl, ICar, etc...

Usar este tipo de comodines es como echar balones fuera, no comprometerse con el código que se está escribiendo. Al fin y al cabo todo son "Utils" y "Tools", como el software mismo. Es información redundante que no aporta valor. Quien consume un objeto no tiene más ayuda por leer el sufijo "Impl" o el prefijo "I". Es mero descuido del que eligió el nombre de ese artefacto. Hay que pensar que el código lo escribimos para otras personas, no para las máquinas. Las máquinas tragan código binario y no entienden de nombres. El hecho de que la API del framework Microsoft .Net incluya el prefijo "I" para las interfaces no lo convierte en una buena práctica, aunque en algún caso puede tener sentido siendo un framework base y genérico (horizontal), pero desde luego en el desarrollo de soluciones de negocio (verticales) no aporta ningún valor.
Si nos encontramos con la dificultad de no saber qué nombre poner a una interfaz para que no sea idéntico a la clase que la implementa, seguramente es que no hace falta crear una interfaz. Una clase ya es en sí misma una interfaz, pero con implementación. Si la escribimos bien se puede extender y reimplementar, sin necesidad de definir interfaces vacías. En otros lenguajes como Python o Ruby ni siquiera existe el concepto de interfaz sin implementación. 
   
El lado opuesto de los nombres demasiado abstractos es el de los nombres que tienen más información de la que se necesita:
GetNameString, ThrowExceptionIfEmpty, ValidateAndSave, ...

En los nombres de variables y métodos no deben aparecer tipos de datos. Considerando que deben expresar el lenguaje del dominio del problema, "String" o "Boolean" no tienen ningún sentido. Los entornos de desarrollo permiten saber fácilmente cuál es el tipo de dato devuelto por un método si lo necesitamos en algún momento. En cuanto a describir la implementación de un método en su nombre, el problema es que si le cambiamos algún detalle podría quedar nombre obsoleto. Hay que pensar qué responsabilidad tiene el método y nombrarlo en función a ella, en lugar de contar qué es lo que hace. Así el método "ThrowExceptionIfEmpty" podría llamarse "AssertThatInputIsValid" tal que en el futuro si decidimos que las reglas de validación cambian, el nombre del método sigue siendo apropiado.

- Comportamiento configurable según base de datos
A veces queremos cambiar el comportamiento de la aplicación dependiendo del rol del usuario o de cualquier otra circunstancia, de manera dinámica, sin hacer cambios en el código. Por ejemplo mostrar determinados elementos del menú de la interfaz de usuario según la configuración de permisos, renderizar una aplicación web de diferente manera según el dispositivo que la consume, etc. Y existe la tentación de que sea la base de datos y/o un fichero de texto de configuración quien contenga todo el conocimiento referente a los cambios de comportamiento. El gran problema es que ni una base de datos relacional ni un fichero de configuración, pueden expresar comportamiento con la claridad que lo hacen los objetos. La estructura tabular de una base de datos SQL no soporta el modelado de las ideas humanas. Si partimos de tablas, el código fuente que conecta la gestión de los cambios de comportamiento con la base de datos, será muy dificil de entender y por tanto de mantener, ya que nos fuerza a pensar de una manera que no es natural. Incluso para dotar de distinto comportamiento la aplicación, es decir, para introducir una nueva configuración, hay que ser todo un experto manipulando columnas y tablas. Por si fuera poco, la automatización de pruebas se hace casi imposible.
En última instancia, tal vez haya que alojar algunos datos de configuración en soporte físico a traves de ficheros o de base de datos, pero la gestión de cambios de comportamiento debe estar basada en objetos. Mediante inyección de dependencias hacemos que la aplicación cambie de comportamiento dinámicamente sin que la configuración sea infernal. 
Ejemplo: para mostrar diferentes elementos de menú según el rol del usuario, podemos tener un objeto que sabe qué elementos debe mostrarle. Ese objeto se configurará o no, con colaboradores. Supongamos que se trata de un menú con acciones para gestionar ficheros. Podemos usar una jerarquía de clases donde la clase base muestra todos los elementos de menú. Luego podría haber clases que la extienden y dejan de mostrar ciertas acciones según el permiso:

       class ActionsMenu:
             ...

       class AdminActionsMenu: ActionsMenu
             ...

       class GuestActionsMenu: ActionsMenu
             ... 

Cuando el usuario entra al sistema con sus credenciales, una factoría puede construir la clase de manejo del menú correspondiente a sus permisos. Si no hace falta añadir entradas al menú de manera dinámica durante la ejecución, las opciones del menú podrían estar incluso escritas en el código del objeto que maneja el menú (hardcoded). De esta manera tendriamos que generar distintas versiones de la aplicación para tener nuevas opciones en el menú. Para más potencia, podemos intercalar un framework de inyección de dependencias que nos permita indicar en un fichero xml qué clases queremos que inyecte según el entorno. 
Si esta opción no conviene, podemos apoyarnos en otros ficheros de configuración o base de datos, asumiendo un coste de complejidad adicional en el proceso de despliegue de la aplicación y también la posibilidad de introducir defectos al editar la configuración.

Mientras estamos dentro de los límites de nuestro código, podemos añadir tests automaticos hasta cubrir el 100% de los casos. Nos podemos hacer entender en el lenguaje del dominio y añadir cambios con agilidad. 

Cuando la potencia del código fuente sea insuficiente, podremos recurrir a los soportes externos pero con consciencia de las ventajas y los inconvenientes que suponen.


----------------------------
Cosas que me faltan:
- rompiendo el principio de liskov
- mezclando paradigmas: pasando funciones como argumentos
- gestion de las excepciones --> esto da para un capitulo  
- recomendar Clean Code al final del capitulo para más info


