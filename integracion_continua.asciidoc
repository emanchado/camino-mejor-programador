Integración Continua
====================
Yeray Darias Camacho <ydarias@gmail.com>

Independientemente de si el equipo de desarrollo sigue una metodología 
clásica en cascada o algún tipo de metodología ágil, hay un momento decisivo
que determina el éxito del proyecto. Este momento es el despliegue de la 
aplicación en los sistemas del cliente, lo que conocemos como sistema de
producción.

Generalmente este suele ser un momento muy tenso porque es muy raro que todo
funcione a la primera. Si se sigue una metodología en la que predomine el 
desarrollo iterativo, en el que las funcionalidades se van entregando poco a 
poco, se minimiza ligeramente el impacto, siempre y cuando al final de cada
iteración se haya desplegado en el sistema de producción real. Pero generalmente
sigue siendo un momento incomodo, se suelen producir errores porque las máquinas
de desarrollo tienen configuraciones diferentes a las máquina de producción, el
rendimiento no es tan bueno porque la base de datos de producción tiene una
cantidad mucho mayor de información, o cualquier otro detalle que no se tuvo en
cuenta durante el desarrollo.

Para resolver este problema aparece una nueva "filosofía", o práctica,
denominada Integración Continua. Para muchas personas la Integración Continua es
tener un servidor Jenkins o Cruise Control construyendo la aplicación 
continuamente. Nada más lejos de la realidad, cuando he utilizado la palabra
filosofía lo he hecho porque la Integración Continua es un modo de desarrollar
un poco diferente al habitual, y que requiere de una serie de buenas prácticas y
la aceptación de las mismas por el equipo de desarrollo. Se ha de convertir en
un hábito que se realice de forma automática, casi sin darnos cuenta. 

Desarrollo en un equipo que utiliza Integración continua
--------------------------------------------------------
La siguiente descripción de un día de trabajo, en un equipo que realiza 
integración continua, ayudara a ilustrar el proceso y comprender los elementos
necesarios para llevarla a cabo.

Al principio del día lo normal es seleccionar la siguiente tarea más importante
a realizar. En base a la reunión de sprint footnote:[Reunión de aproximadamente
una hora en la que se decide cuales serán las tareas a incluir en la siguiente
versión de la aplicación.] y al stand-up meeting footnote:[Breve reunión de
seguimiento, diaria, que realiza todo el equipo, donde expone en que se trabajó
el día anterior, en que se trabajará hoy y si existen impedimentos para llevar a
cabo alguna de las tareas en ejecución.] siempre existe una lista de tareas
priorizadas a disposición del equipo de desarrollo, por lo que es muy sencillo
saber que es lo siguiente que debemos hacer. Escogemos la siguiente tarea más
prioritaria y volvemos a nuestra mesa de trabajo.

El primer paso será actualizar el código fuente del que disponemos con la 
versión más nueva que exista en el repositorio central. Esto nos permitirá estar
seguros de que todo el equipo está trabajando con la misma versión del código
sin necesidad de realizar complejos procesos manuales. De igual manera, si fuese
la primera vez que vamos a trabajar en un proyecto, no tenemos más que descargar
una copia limpia del repositorio de código y empezar a hacer nuestro trabajo.

A lo largo del día implementaremos la nueva funcionalidad que debería ser 
bastante pequeña como para terminarla en una jornada de trabajo, y debería 
incluir una serie de tests que verifiquen que posee el comportamiento deseado. 
Se puede leer más sobre los tests en otros capítulos del libro.

Cuando la funcionalidad está terminada, antes de subir ningún cambio al 
repositorio, actualizaremos el código fuente con los cambios de nuestros
compañeros y nos aseguraremos de que la aplicación sigue construyéndose
correctamente, y que los tests del proyecto están en verde, es decir que pasan
todos sin ningún problema. Si por el contrario aparece algún error, lo 
arreglaremos inmediatamente. Nunca, bajo ningún concepto se debe subir código al
repositorio sin revisar que los tests pasan correctamente y la aplicación se
puede construir sin incidencias. Además es recomendable acceder a la aplicación
y revisar  rápidamente que todo sigue funcionando adecuadamente. Por lo general
los tests unitarios no tienen una cobertura del 100% o simplemente no pueden
probar detalles de infraestructura que son más sencillos de probar a mano. 

Una vez hemos realizado todos los pasos anteriores, podemos hacer un commit y
guardar nuestros cambios en el repositorio de código, lo que permite que el
resto del equipo se actualice y los tengan disponibles en cuestión de segundos.

Es el momento en el que hacemos el commit cuando el servidor de Integración
Continua comienza a trabajar, aunque en realidad el proceso de Integración
Continua ya ha empezado desde el primer paso. El servidor de Integración se 
descargará una versión nueva del código fuente, con los todos los cambios
llevados a cabo por el equipo de desarrollo, pasará los tests y tras hacer
la construcción el proyecto lo desplegará en una "réplica" de la máquina de
producción. Todo de forma totalmente automatizada. El propio de servidor de
Integración Continua podría pasar algunas pruebas extras, como por ejemplo
análisis estático de código, análisis de cobertura, o cualquier otro detalle que
sería muy tedioso pasar en el proceso de desarrollo porque requiere demasiado
tiempo.

También podría haber ocurrido un error, en ese caso el servidor de Integración
Continua nos avisaría con algún mensaje en la consola del mismo o simplemente
con el envío de un correo electrónico. En ese momento tendremos que inspeccionar
cual ha sido el error y resolverlo para subir una nueva versión corregida. Como
el error se genera a los pocos minutos y no han pasado días ni meses, es muy
fácil encontrar donde esta el problema.

Ventajas de la Integración Continua
-----------------------------------
No conozco ningún estudio empírico que lo pueda demostrar, pero si hablas con 
personas que hayan utilizado Integración Continua, todos te dirán que reduce 
de manera increíble el número de errores en el producto final. Para mi también
es la mayor ventaja que aporta, porque un producto final con pocos o incluso
ningún error es a fin de cuentas el objetivo que todos deseamos como
desarrolladores.

Pero no hay que olvidarse de la otra gran ventaja que aporta esta práctica, la 
transparencia del proceso. Como todos trabajamos contra el mismo repositorio de
código y la información del servidor de integración es pública, para todo el 
equipo e incluso a veces para el cliente, se conoce con total precisión el 
estado real del proyecto. No hay que esperar durante meses para saber como van 
las cosas y las reuniones de seguimiento pueden ser cortas y precisas.

Elementos indispensables de la Integración Continua
---------------------------------------------------
Como se ha comentado anteriormente, el primer aspecto necesario para poder 
realizar Integración Continua es el uso de repositorios de código. Es 
indispensable que todos los cambios realizados por el equipo se encuentren
centralizados en un único lugar, y además deben ser accesibles fácilmente para
que todo el mundo trabaje siempre sobre la última versión disponible. Existen
multitud de opciones en el mercado y muchas de ellas gratuitas, la elección es
personal, pero recordad que es indispensable disponer de una herramienta de este
tipo.

Tener un repositorio de código es la primera fase de la automatización del 
proceso, pero además la copia que hay en el mismo debe contener todos los 
ficheros necesarios para la construcción del proyecto y es necesario que dicha
construcción se pueda hacer sin necesidad de un IDE, y de forma automatizada. En
el mundo Java esto se suele hacer con herramientas como Ant, Maven y últimamente
Gradle, pero hay opciones similares para todos los lenguajes y plataformas, solo
tienes que buscar un poco, probar y quedarte con la que más te guste, el único
requisito es que el proceso de construcción esté automatizado por completo, 
desde el enlazado de librerías, hasta la compilación, pasando por la ejecución 
de los tests unitarios. Esto es necesario porque el servidor de Integración
Continua se suele basar en estos "scripts" para poder integrar por si mismo sin
necesidad de intervención humana.

Para que el proceso de integración sea efectivo es necesario tener una batería
de tests que verifiquen el adecuado comportamiento de la aplicación, con
herramientas como los frameworks xUnit. Lo más complicado en este punto es
realizar tests estables y efectivos, aunque este tema es un capítulo entero en
si mismo.

Por último, hay que destacar el proceso iterativo. De nada sirve hacer 
Integración Continua si la construcción de la aplicación se hace totalmente al
azar, en bloques que no tienen relación alguna, o entregando funcionalidades
cada tres meses. Se deben realizar iteraciones cortas, por ejemplo de dos
semanas es una cifra bastante aceptable, aunque hay equipos que prefieres una
semana u otros que prefieren 4. Te recomiendo que empieces por dos y luego vayas
adaptándolo a tu propio equipo. Entregando nueva funcionalidad al cliente desde
el primer momento, aunque sea pequeña, logras que te pueda dar información. Por
ejemplo, algo que aunque funcione no lo hace como el cliente pensaba, fallos de
usabilidad que para el desarrollador no eran aparentes, problemas de carga que
no aparecían con los datos de desarrollo pero sí con los de producción. Este 
tipo de problemas son muy comunes, pero con el desarrollo iterativo te adelantas
y logras trabajar en un entorno más controlado, atendiendo a los problemas más 
importantes en el momento adecuado.

Un paso más allá
----------------
Con los pasos descritos hasta el momento ya tendríamos un proceso bastante 
completo y que a buen seguro mejorará enormemente la calidad de nuestro 
producto. Pero podemos ir un poco más allá y utilizar el servidor de integración
para que haga ciertas tareas relativamente complejas por nosotros.

Por ejemplo podríamos configurar el servidor para que haga análisis estático de
código, de forma que podría buscar en todo el código bloques sospechosos, 
bloques duplicados, referencias que no se utilizan, entre otras cosas. A simple
vista puede parecer algo irrelevante, pero hay que recordar que la complejidad 
es lo que más ralentiza el proceso de desarrollo, por lo que un código con 
menor número de líneas y referencias inútiles será más sencillo de leer y 
entender.

Otra operación que podemos automatizar, y que el servidor de integración podría
hacer por nosotros, es la realización de pruebas end-to-end sobre la aplicación.
Imaginemos que estamos desarrollando una aplicación web, podríamos crear tests
con alguna herramienta de grabación de la navegación, como por ejemplo Selenium 
y lanzarlos con cada construcción que haga el servidor. Es un tipo de prueba que 
requiere mucho tiempo y no sería viable que se lancen con cada compilación del
desarrollador, pero para el servidor de integración no habría ningún problema.
Este es solo un ejemplo más de la cantidad de cosas que puede hacer un servidor
de integración continua por nosotros, y que nos ayudará a mantener un producto
estable y testeado de manera totalmente automática.

Para acabar me gustaría utilizar algunos comentarios escuchados por Martin
Fowler cuando habla de Integración Continua con otros desarrolladores. La
primera reacción suele ser algo como "eso no puede funcionar (aquí)" o "haciendo
eso no cambiará mucho las cosas", pero hay otra muy distinta que es "sí,
nosotros lo hacemos - ¿cómo puedes vivir sin eso?". Ahora es tu elección si 
decides probarlo o no, pero antes de hacerlo piensa en lo poco que tienes que 
perder y lo mucho que puedes ganar.

[bibliography]
Bibliografía
------------
- [[[continuosintegration]]] Paul M Duvall 'Continuos Integration: Improving
  Software Quality and Reducing Risk' ISBN 978-0321336385
- [[[continuosdelivery]]] Jez Humble and David Farley 'Continuos Delivery'  
  Addison-Wesley Professional ISBN 978-0321601919
- [[[cifowler]]] Martin Fowler 'Continuous Integration' 
  http://www.martinfowler.com/articles/continuousIntegration.html
- [[[xpexplained]]] Kent Beck and Cynthia Andres 'Extreme Programming Explained:
  Embrace Change (2nd Edition)' ISBN 978-0321278654
- [[[]]] Carlos Blé Jurado 'Diseño Ágil con TDD' ISBN 978-1445264714
- [[[xunit]]] Frameworks xUnit http://en.wikipedia.org/wiki/XUnit