Introducción a las APIs REST con HTTP (1): HTTP y APIs orientadas a datos
=========================================================================
Enrique J. Amodeo_Rubio <eamodeorubio@gmail.com>
:Blog: http://eamodeorubio.wordpress.com
:Twitter: @eamodeorubio

Introducción
------------

Tras muchos años intentando crear servicios web basados en tecnologías RPC como CORBA o SOAP, la industria del desarrollo de software se encontraba en un punto muerto. Cierto, se había conseguido hacer que un servicio implementado en .NET consiguiera comunicarse con uno escrito en Java, o incluso con otro hecho a base de COBOL, sin embargo todo esto sabía a poco. Es normal que supiera a poco, se había invertido cantidades ingentes de dinero en distintas tecnologías, frameworks y herramientas, y las recompensas eran escasas. Lo peor es que además las compañías se encontraban encalladas en varios problemas.

Por un lado la mantenibilidad de la base de código resultante era bastante baja. Se necesitaban complejos IDEs para generar las inescrutables toneladas de código necesarias para interoperar. Los desarrolladores tenían pesadillas con la posibilidad de que se descubriera algún bug en la herramienta de turno, o de que algún parche destruyera la interoperabilidad. Y si se necesitaba alguna versión o capacidad más avanzada de SOAP probablemente el IDE no lo soportara o tuviera que ser actualizado.

Por otro lado para depurar cualquier problema de interoperabilidad había que bajar al nivel de HTTP: ¿estarían las cabeceras apropiadas? ¿La serialización del documento SOAP es conforme a "Basic Profile"[3]? ¿No se suponía que SOAP era transparente al protocolo?

Finalmente también había descontento. Se había soñado con un mundo de servicios web interoperables de manera transparente, organizados en directorios UDDI y demás. Al final esto no se consiguió, sólo interoperaban servicios entre distintos departamentos de una misma empresa, o de forma más rara algún servicio llamaba a otro servicio de otra empresa, todo con mucho cuidado y en condiciones bastante frágiles.

Cuando la situación se hizo insostenible, y algunos gigantes de la informática como Amazon, Google o Twitter necesitaron interoperabilidad a escala global y barata, alguien descubrió el camino al futuro mirando hacia el pasado, y descubrió REST...

¿Qué es REST?
~~~~~~~~~~~~~

REST[1] no es una tecnología, ni siquiera una arquitectura, REST es un estilo arquitectónico. Es un conjunto de restricciones a respetar cuando diseñamos la arquitectura de nuestros servicios web. Las restricciones propuestas por REST son las siguientes:

* REST no es RPC, sino orientado a recursos. Los servicios web no representan acciones, sino entidades de negocio. En vez de publicar verbos como por ejemplo "comprar", se publican nombres como "carrito de la compra" o "pedido". En este sentido podemos pensar en RPC como intentar definir la API de un sistema en base a procedimientos, es decir, es un paradigma procedural. Sin embargo REST define la API como un conjunto de recursos que representan objetos de negocio; este enfoque está mucho más cercano a la OO que a otra cosa. En lo sucesivo usaré las palabras "recurso", "entidad" y "servicio" de forma intercambiable, aunque realmente la más correcta es "recurso".
* Cada recurso posee un identificador único universal (UUID o GUID) con el cual podemos hacer referencia a él. Estas referencias las puede usar un cliente para acceder al recurso, o bien puede usarse para crear una relación desde un recurso a otro. Crear estas relaciones es tan sencillo como incluir una referencia de un recurso a otro usando el UUID del último.
* La implementación, y la forma exacta en la que un recurso se representa internamente, debe ser privada y no accesible al exterior.
* Cada recurso tiene un interfaz, o conjunto de operaciones que admite. Basta saber el UUID del recurso para poder enviarle la operación que queremos realizar. 
* La interfaz es homogénea para todos los recursos. Esto quiere decir que todos los recursos deben escoger las operaciones que soportan de un conjunto de acciones predefinidos. Este conjunto de operaciones permitidas es una característica específica de cada arquitectura REST y no puede cambiarse. Como consecuencia no podemos inventar nuevas operaciones, sino que tenemos que modelar esas nuevas operaciones como recursos. Por ejemplo, en un sistema REST no podemos añadir una operación "reservarHotel", sino que tendríamos que crear un nuevo recurso llamado "ReservaDeHotel". Sin embargo el conjunto de operaciones mínimo que debe tener un sistema REST es "leer", "actualizar" y "crear".
* Las operaciones se realizan mediante transferencia de estado del recurso. El cliente puede pedir que una copia del estado de un recurso sea transferido desde el servidor al cliente (leer), modificarlo, y mandar la copia modificada al servidor usando alguna de las operaciones de modificación permitidas (actualizar o crear).
* Las operaciones son _stateless_. Es decir, el resultado de una operación es independiente de la conversación que hayan mantenido el cliente y el servidor anteriormente. Como consecuencia de esto toda la información necesaria para llevar a cabo la operación debe mandarse como parámetros de ésta.
* Los recursos son multimedia, es decir, el estado de un recurso puede ser representado mediante distintos formatos. Por formato se entiende el formato concreto de serialización del estado cuando se manda por red. Algunos ejemplos de formatos son XML, JSON, imagen JPEG, imagen GIF, etc. Como vimos antes el estado de un recurso puede ser copiado desde un servidor al cliente o viceversa, pero por otro lado el formato interno del recurso es privado y desconocido por el cliente. Para que esto funcione el cliente debe especificar al servidor que formatos entiende y viceversa, y ponerse de acuerdo en el conjunto de formatos más conveniente a usar que ambas partes entiendan.

REST es el acrónimo para "REpresentational State Transfer". Veamos lo que significa con un pequeño ejemplo de como sería la reserva de una habitación de hotel usando REST:

1. El cliente pide (leer) el recurso "Habitaciones" realizando una operación leer contra el servidor. En dicha operación se pasan parámetros correspondientes al rango de fechas de disponibilidad y características de la habitación.
2. El servidor responde con un documento representando un resumen de la lista de habitaciones que conforman a los criterios de búsqueda. El resumen de cada habitación contiene el UUID de ésta, y el UUID de un recurso asociado que representa las reservas de dicha habitación.
3. El cliente opcionalmente puede pedir (leer) el detalle completo de cada habitación usando el UUID contenido en el resumen.
4. El cliente envía una operación de "crear" al recurso que representa las reservas de la habitación elegida. Recordemos que el UUID de este recurso estaba tanto en el resumen como en el detalle de cada habitación. Al enviar la operación pasa como parámetro los detalles de la reserva.
5. El servidor puede responder de varias formas:
    . Rechazando la petición.
    . Devolviendo el UUID del recurso que representa la reserva que acabamos de crear e indicando que la reserva está completa.
    . Devolviendo el UUID del recurso que representa la reserva que estamos creando, y además un documento donde se pide información adicional, tal vez detalles de forma de pago o nombre de los huéspedes. El cliente debería modificar el documento e invocar la operación "actualizar" contra el UUID. De ahí se volvería al paso 5.

Como se ve toda la dinámica se basa en una conversación entre el cliente y el servidor, donde el cliente pide una copia del estado del recurso al servidor, el servidor se lo devuelve en un formato concreto (documento), el cliente lo modifica y se lo vuelve a mandar al servidor. Esto a su vez puede terminar en modificar el estado del recurso o crear uno nuevo. A partir de ahí el servidor devuelve un nuevo documento con el resultado de la operación y quizás el UUID del nuevo recurso creado, y la conversación continúa. Ahora quizás se entienda el significado de "REpresentational State Transfer", ya que todas la operativa se basa en transferir una representación (formato de documento) del estado de un recurso entre el cliente y el servidor y viceversa.

¿Por qué usar REST?
~~~~~~~~~~~~~~~~~~~

¿Queremos diseñar un sistema de servicios web? Pues lo más sensato es ver como funciona la web e investigar cómo funciona el único caso de éxito de interoperabilidad a escala global que existe en la actualidad. ¿Cuál es tal caso de éxito? La world wide web. Sí querido lector, las páginas web que navegamos a diario son un caso real de interoperabilidad a escala global, sólo es necesario usar un navegador decente que entienda los formatos disponibles para cada página (HTML, GIF, JPEG, códecs de video, etc) para poder consumirlas. No importa que el fabricante del navegador y el autor de la página no hayan interactuado en la vida, o que cada autor de cada página sea totalmente independiente entre ellos.

El enfoque RPC basado en SOAP ha fracasado, no conozco ningún sistema basado en este paradigma que alcance niveles de interoperabilidad tan altos a costes tan bajos como la world wide web. Por lo tanto la world wide web es un ejemplo a seguir, una guía a las decisiones de diseño necesarias para hacer servicios interoperables.

Es trivial darse cuenta de que si quieres hacer servicios web, tienes que respetar los principios de diseño de la web y diseñar tus servicios con ellos en mente. ¿Cuáles son los principios arquitectónicos de la web? Los principios REST.

Llevando REST al mundo real
---------------------------

Vayamos a lo práctico, ¿cómo implementar REST en el mundo real?

El protocolo HTTP
~~~~~~~~~~~~~~~~~

El protocolo HTTP[2], pieza fundamental en la que se basa la world wide web, especifica como intercambiar entre cliente y servidor recursos web. Es un protocolo idóneo para implementar servicios web, ya que además de ser ubicuo, su diseño sigue los principios REST. Veamos ahora como funciona este protocolo y como encaja en el estilo arquitectónico REST.

HTTP es un protocolo que se sitúa al nivel de aplicación, incluyendo algo del nivel de presentación, dentro de la pila ISO[4]. En principio está diseñado para ser ejecutado sobre TCP o sobre transporte seguro TLS/SSL, aunque no sería descabellado mandar mensajes HTTP sobre otro protocolo de transporte. Se basa en un paradigma sencillo petición/respuesta, sin ningún tipo de memoria ni sesión de usuario, es decir, es un protocolo stateless.

El mensaje de petición en HTTP consta de una primera línea de texto indicando la versión del protocolo, el verbo HTTP y la URI destino. El verbo HTTP indica la operación a realizar sobre el recurso web localizado en la URI destino. Más adelante hablaremos más, tanto sobre los verbos que hay, como sobre las URIs. A continuación, y de forma opcional, vienen las cabeceras. Cada cabecera va en una línea de texto distinta, y consiste en el nombre de la cabecera seguido de su valor, ambos separados por ":". Opcionalmente la petición puede llevar un cuerpo, separado por una línea en blanco del encabezamiento del mensaje, y que contiene un documento. Dicho documento puede estar en cualquier formato (incluso binario), aunque normalmente suele ser texto plano, HTML, XML o JSON. El formato del documento se define en la cabecera "Content-Type".

Los mensajes de respuesta HTTP siguen el mismo formato que los de petición, excepto en la primera línea, donde se indica el código de respuesta y una explicación textual de dicha respuesta. El código de respuesta indica si la petición tuvo éxito o no y por qué razón.

Un ejemplo de petición HTTP sería:
------------------------------
POST /server/payment HTTP/1.1
Host: www.myserver.com
Content-Type: application/x-www-form-urlencoded
Accept: application/json
Accept-Encoding:gzip,deflate,sdch
Accept-Language:en-US,en;q=0.8
Cache-Control:max-age=0
Connection:keep-alive

orderId=34fry423&payment-method=visa&card-number=2345123423487648&sn=345
------------------------------

Y como respuesta:
------------------------------
HTTP/1.1 201 Created
Content-Type: application/json;charset=utf-8
Location: https://www.myserver.com/services/payment/3432
Cache-Control:max-age=21600
Connection:close
Date:Mon, 23 Jul 2012 14:20:19 GMT
ETag:"2cc8-3e3073913b100"
Expires:Mon, 23 Jul 2012 20:20:19 GMT

{
  "id":"https://www.myserver.com/services/payment/3432",
  "status": "pending"
}
------------------------------

Las URIs
^^^^^^^^

Las URI[5] son los identificadores globales de recursos en la web, y actúan de manera efectiva como UUIDs REST. Las URIs tiene el siguiente formato:

------------------------------
<esquema>:<parte específica esquema>/<ruta><querystring><fragmento>
------------------------------

El esquema, en el caso de una URL(\*), indica qué protocolo se debe usar para acceder al recurso. En el caso que nos ocupa podría ser "http", o "https" si usamos transporte seguro. Si es una URN(*) el esquema es "urn". En nuestro caso nos interesan las URLs, e ignoraremos las URNs en el resto de la discusión.

Tras el esquema, viene la parte específica del esquema. En las URLs sería la dirección del servidor donde se encuentra el recurso. Esta dirección se puede especificar mediante una dirección IP o mediante un nombre de dominio, y se separa del esquema mediante "//". Opcionalmente se especifica el puerto a usar en la conexión concatenándolo con ":". Esto no es necesario si se va a usar el puerto estándar del protocolo especificado. El puerto estándar para "http" es el 80 y para "https" es 443.

A continuación viene la ruta del recurso dentro del servidor. Tiene la forma de un conjunto de segmentos separados por "/"(**).

De forma opcional tenemos la "query string", que indica parámetros adicionales de la URI a ser procesados en el servidor por la aplicación. Su uso más común es el de especificar criterios de búsqueda o filtrado o bien añadir parámetros o tokens de control. La "query string" se separa de la ruta mediante el carácter "?" y consiste en una serie de pares clave/valor separados por "&". Dentro de cada para la clave y el valor se separa por "=".

Finalmente y también de forma opcional tenemos el fragmento, que se separa del resto de la URI mediante "#". Al contrario que la "query string" el fragmento no se procesa en servidor, sino que está pensado para ser procesado por la aplicación cliente. Por lo tanto no tiene impacto en el diseño de servicios web.

Las siguientes son todas URIs:

------------------------------
http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.2
https://www.myserver.com/rest/books?author=vega
ftp://user@ftp.server.com/dir/somefile.txt
urn:oasis:names:specification:docbook:dtd:xml:4.1.2
urn:uuid:a74fc10b-58cc-4379-f5c7-1e02b2a3d479
------------------------------

(*) Las URLs y URNs son casos concretos de URIs. Las primeras identifican un recurso de red mediante una IP o un DNS, las segundas son simples UUIDs lógicos con un espacio de nombres asociados. Para más detalle ver [5]

(**) Otras cosas pueden aparecer, para ello se usan otros caracteres como ";" o "@". Esto raramente se usa, con la interesante excepción del ";" para indicar el identificador de sesión servidora. Para más detalle ver [5]

Los verbos HTTP
^^^^^^^^^^^^^^^

Una característica completamente alineada con REST del protocolo HTTP es el hecho de que tenga una interfaz uniforme para todos los recursos web. HTTP define un conjunto predefinido y cerrado de acciones o métodos HTTP(*). Es importante tener en cuenta que la propia especificación define los conceptos de "seguridad" e "idempotencia", y clasifica los métodos conforme a estos dos criterios.

Un método se considera "seguro" si no produce efectos secundarios. Por efecto secundario se entiende cualquier modificación del estado del servidor o interacción de éste con cualquier otro sistema que produzca efectos perceptibles por el usuario. Normalmente sólo los métodos que representan lectura se consideran seguros.

Un método es idempotente, si la ejecución repetida de éste, con exactamente los mismos parámetros, tiene el mismo efecto que si sólo se hubiera ejecutado una vez. Esta propiedad nos permite reintentar con seguridad una petición una y otra vez y tener la seguridad de que la operación no se va a duplicar. De forma muy común, debido a cortes y congestiones de red, el cliente no recibe la confirmación de si una operación se ha realizado o no. Tal vez la petición ha llegado al servidor y se ha ejecutado, con lo que no deberíamos duplicar la operación, o tal vez simplemente se ha quedado por el camino y debemos reintentarla. Los métodos idempotentes nos permiten recuperarnos de esta circunstancia simplemente repitiendo la petición, ya que nos aseguran que no se duplicará la operación si estuviéramos en el primer caso.

Los métodos HTTP más comunes son los siguientes (**):

[options="header"]
|=======================================================================
| Método  |Seguro|Idempotente|        Semántica                         
| GET     |  Sí  |    Sí     | Leer el estado del recurso               
| HEAD    |  Sí  |    Sí     | Leer, pero sólo las cabeceras            
| PUT     |  No  |    Sí     | Actualizar o crear
| DELETE  |  No  |    Sí     | Eliminar un recurso                      
| POST    |  No  |    No     | Cualquier acción genérica no idempotente 
| OPTIONS |  Sí  |    Sí     | Averiguar las opciones disponibles de comunicación de un recurso
|=======================================================================

En general el uso de cada método es bastante explicativo, y más adelante veremos cómo usarlos así como buenas prácticas. Sin embargo conviene aclarar un par de aspectos. El primero es la diferencia entre HEAD y GET. Ambos leen el recurso, pero el segundo devuelve tanto los datos del recurso web, como las cabeceras HTTP, mientras que el primero sólo las cabeceras. Por otro lado el método POST es bastante misterioso y objeto de frecuentes malentendidos. En general se usa para crear un nuevo recurso, modificar uno existente o para ejecutar una acción genérica que no sea idempotente como realizar una transacción monetaria. Como veis la semántica de PUT parece que se solapa con la de POST de alguna manera, y esto es fuente de numerosos malentendidos. Más adelante aclararemos este tema.

El método OPTIONS se usa para determinar las opciones de comunicación de un recurso, tales como qué métodos HTTP podemos usar contra esa URI. El resultado de OPTIONS no es _cacheable_, ya que el conjunto de métodos que podemos usar puede cambiar con el estado en el que se encuentre el recurso. Junto con HEAD nos permiten descubrir automáticamente cómo podemos comunicarnos con el servidor.

(*) Los métodos HTTP también son llamados verbos HTTP en multitud de fuentes.
(**) Existen otros métodos que no suelen ser muy usados en servicios REST, como CONNECT o TRACE.

Los tipos MIME
^^^^^^^^^^^^^^

Otro aspecto muy apropiado para el desarrollo de servicios REST con el protocolo HTTP es su soporte para negociar distantos formatos (representaciones) a usar en la transferencia del estado entre servidor y cliente (y viceversa).

En HTTP cada uno de estos formatos se constituye lo que se llama un tipo MIME distinto y existen muchos tipos MIME estandarizados[6]. Cada tipo MIME tiene el formato de <tipo>/<subtipo>. Algunos tipos MIME muy usados: "application/json", "application/xml", "application/atom+xml", "application/javascript", "text/html" y "audio/vorbis".

A veces en el subtipo suele aparecer el caracter "+". Esto indica que el tipo MIME es una variante de otro tipo principal. Por ejemplo "application/atom+xml", indica que el tipo MIME es una variante del más genérico "application/xml" pero siguiendo el XML schema de atom. Otra convención común es que si el subtipo empieza por "x-" entonces el tipo MIME no es estándar, sino propietario.

¿Cómo se negocia el tipo MIME entre el cliente y el servidor? Es sencillo, en el mensaje de petición se incluye una cabecera "Accept", con una lista de tipos MIME que el cliente entiende, el servidor selecciona el tipo que más le interese de entre todos los especificados en la cabecera "Accept", y devuelve la respuesta. Si el servidor no entiende ninguno de los tipos MIME propuestos devuelve un mensaje con código 406, indicando que es incapaz de aceptar la petición. Si no se incluye la cabecera "Accept" se indica que se acepta cualquier tipo MIME. Por otro lado, ya sea en la petición como en la respuesta HTTP, la cabecera "Content-Type" debe contener el tipo MIME del documento que aparece en el cuerpo del mensaje. Si el mensaje no tiene cuerpo no debe aparecer dicha cabecera.

En la cabecera "Accept", la lista de tipos MIME se especifica mediante lo que se llama un "media range". Un "media range" es una lista separada por comas de tipos MIME, donde cada uno de los tipos MIME puede ir acompañados por uno o más parámetros. Para indicar un parámetro en un tipo MIME se usa el ";". Así "text/html;level=3" indica el tipo MIME "text/html" con un parámetro "level" con valor "3". En general el significado del parámetro es específico de cada tipo MIME. Un ejemplo de parámetro podría ser "charset" indicando la codificación de caracteres dentro de un formato de tipo texto o de tipo aplicación no binario. Ej. "text/plain; charset=ISO-8859-1" y "application/json; charset=UTF-8"

Además en un "media range" pueden aparecer expresiones de rango. Hay dos:

1. "\*/*" indica cualquier tipo MIME
2. "<tipo>/\*" indica cualquier subtipo dentro del tipo. Por ejemplo "image/*" indica cualquier imagen en cualquier formato.

Un "media range" no sólo especifica una lista de tipos MIME aceptables, sino tambien un orden de preferencia, de tal manera que el servidor debe intentar elegir el tipo MIME que soporte pero que tenga mayor preferencia para el cliente. La preferencia se calcula usando las siguientes reglas:

1. Si el tipo MIME tiene un parámetro llamado "q", usar el valor de ese parámetro como preferencia. Este valor debe estar entre 0 y 1, y el parámetro "q" debe ser el primero.
2. Si no existe parámetro "q", asumir que tiene un valor de 1.
3. Si hay empate en el valor de "q", el orden de preferencia para desempatar, de mayor a menor es el que sigue:
 a. El tipo MIME con mayor número de parámetros
 b. Las expresiones <tipo>/*
 c. La expresión \*/*

Pongamos un ejemplo, la siguiente cabecera:
---------------------------
Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1, */*;q=0.5
---------------------------

Especifica el siguiente orden de preferencias de tipos MIME:

1. text/html;level=1
2. text/html
3. Cualquier formato que no sea texto
4. Cualquier formato de texto (text/*)

Códigos de estado
^^^^^^^^^^^^^^^^^

En HTTP el mensaje de respuesta contiene en su primera línea lo que se llama el código de estado, que indica el resultado de la operación. Los códigos de respuesta más usados son:

* 200. Indica éxito de la operación de forma genérica. Se usa cuando no hay otro código de éxito más específico. El mensaje de respuesta debe contener un cuerpo, en otro caso se usa 204.
* 201. Indica que se creó con éxito un nuevo recurso web. Suele devolverse cuando ejecutamos un método POST o PUT. En la respuesta se devuelve la URI del nuevo recurso creado dentro de la cabecera "Location". La respuesta puede contener un cuerpo con los datos del nuevo recurso.
* 202. Indica que la petición se ha aceptado pero que no está completa. Se puede devolver en la respuesta un cuerpo con información sobre cuanto queda para que se complete la operación o indicando como monitorizar el progreso de ésta. Es muy útil cuando el servidor esta congestionado o para modelar operaciones de larga duración.
* 204. Indica éxito de la operación de forma genérica. Se usa cuando no hay otro código de éxito más específico. El mensaje de respuesta está vacio y no tiene cuerpo, en otro caso usar 200.
* 301. Indica que el recurso se ha movido a otra URI de forma permanente. La nueva URI se indica en la cabecera "Location" de la respuesta. Este mecanismo de redirección se puede usar para versionar servicios como veremos más adelante.
* 304. Indica que el recurso no se ha modificado. Normalmente es la respuesta de un cache a una operación. La respuesta no contiene cuerpo.
* 400. El mensaje de petición está mal formado.
* 401. La petición no está autorizada, acceso denegado. Las credenciales de la petición son incorrectas (tal vez el usuario no existía o el esquema de autenticación no es correcto) o simplemente la petición no tenía credenciales. Indica la necesidad de volver a hacer la petición con unas credenciales correctas para autenticarse.
* 403. Acceso denegado: las credenciales son insuficientes para acceder al recurso, el usuario no tiene permiso.
* 404. Recurso no encontrado.
* 405. Método no soportado, la operación HTTP especificada en la petición no está implementada. Un ejemplo de esto sería al intentar actualizar un recurso de sólo lectura.
* 406. La petición no es aceptable. Tal vez el servidor no soporta los tipos MIME aceptados por el cliente.
* 409. Conflicto de versiones. Usado en la implementación de concurrencia optimista (ver más adelante).
* 412. Fallo en la precondición. Usado en la implementación de concurrencia optimista (ver más adelante).
* 500. Se produjo un error inesperado en el servidor. Se puede usar para modelar excepciones en la capa de aplicación.

El uso de muchos de estos códigos de estado es bastante evidente. Más adelante veremos algunos casos de uso concretos.

QoS en HTTP
^^^^^^^^^^^

Existen cabeceras en HTTP que tienen que ver con mejorar la eficiencia de la comunicación.

Por ejemplo, las cabeceras "Content-Encoding" y "Accept-Encoding" nos permiten modificar la codificación del cuerpo de los mensajes. Un caso práctico de esto es comprimir el cuerpo de los mensajes con el algoritmo GZIP para ahorrar ancho de banda.

La cabecera "Keep-Alive" nos permite reutilizar una misma conexión a nivel de transporte (un socket TCP por ejemplo) para varios ciclos de petición/respuesta. Sin esta cabecera cada petición/respuesta iría en una conexión diferente, lo que consumiría mayor cantidad de recursos y aumentaría la latencia.

La cabecera "Upgrade", nos permite cambiar a otro protocolo. Ahora está siendo usada principalmente para cambiar a protocolo WebSocket.

Una cabecera muy usada es "Transfer-Encoding", que nos permite enviar mensajes de longitud variable, lo que es indispensable para hacer streaming.

Afortunadamente como desarrolladores es improbable que tengamos que preocuparnos de todo esto, ya que se gestiona de forma casi transparente a través de la infraestructura. Sin embargo sí que hay aspectos de HTTP relacionados con la calidad de servicio, como la gestión de caché, la seguridad o la concurrencia optimista, que impactan en el diseño de servicios. Veremos más sobre este tema en el próximo capítulo.

HTTP y REST
~~~~~~~~~~~

Como vemos el protocolo HTTP está diseñado para cumplir los principios REST. Tenemos recursos (documentos web), que poseen UUIDs (URIs) y que pueden ser accesibles mediante múltiples representaciones (tipos MIME). Además se tiene un conjunto de operaciones predefinidas, los verbos HTTP, que se pueden utilizar siguiendo petición/respuesta stateless de HTTP. Como se ve HTTP tiene todos los ingredientes de una arquitectura REST.

Sin embargo existen formas de usar el protocolo HTTP que no son REST, aunque se le parecen. A estos diseños los llamamos servicios RESTlike, en contraposición a los servicios REST puros o RESTful.

Un ejemplo típico de servicio RESTlike se produce cuando las distintas acciones tienen URI propia. Por ejemplo "http://www.server.com/reserva/123/completar" o también "http://www.server.com/reserva/123?action=completar". Esto rompe con el principio REST más simple, que es que se deben exponer sólo recursos y no operaciones. También rompe el principio REST que indica que sólo los recursos deben tener UUID y ser referenciables.

Otro tipo de servicios RESTlike son aquellos en los que se usa siempre el mismo verbo HTTP para todas las acciones, normalmente POST. En estos diseños se suele usar o bien la URI (como vimos antes), o bien algún parámetro en el cuerpo de la petición, para indicar que acción queremos. En el último caso realmente estamos rompiendo HTTP, ya que como vimos cada verbo tiene un significado distinto y toda la infraestructura de la web está preparado para ello.

Otra práctica que no es REST es tener distintas URIs para pedir el recurso en distintos formatos. Ejemplo: "http://www.server.com/reserva/22.html" y "http://www.server.com/reserva/22.pdf". El tipo de formato se debe indicar en las cabeceras HTTP "Content-Type" y "Accept". Según REST sólo los recursos pueden tener URI, y una misma URI se puede servir usando distintas representaciones.

Recordad que estos enfoques no son REST, no caigais en la tentación.

El buen diseño de servicios web REST se basa en saber como mapear los distintos conceptos de REST al protocolo HTTP. La idea es aprovechar bien todas las capacidades de dicho protocolo para implementar REST sin destruir la semántica estándar de HTTP. De esta forma conseguiremos aprovechar de forma efectiva toda la infraestructura que ya está disponible en la web, como caches, proxies, firewalls y CDNs.

Cuando diseñemos nuestros servicios REST hay que pensar que la API de éstos consta de lo siguiente:

* El diseño de URIs que vayamos a seguir, y al menos la URI de un servicio raíz a partir del cual entrar en el sistema. El cliente sólo debería conocer esta URI raíz.
* Los tipos MIME soportados por los recursos REST.
* Los verbos HTTP soportados. No debemos romper la semántica de dichos métodos HTTP.

Cualquier cambio en alguno de estos puntos implica cambiar el API público de nuestro sistema, y por lo tanto romper la interoperabilidad con nuestros clientes.

En esta sección veremos las prácticas más importantes en este sentido, y cómo podemos aprovechar las capacidades de HTTP en nuestro favor.

APIs orientadas a datos con REST: CRUD
--------------------------------------

El caso de uso más sencillo al diseñar servicios REST con HTTP se produce cuando dichos servicios publican operaciones CRUD(*) sobre nuestra capa de acceso a datos. En este tipo de diseños existen dos tipos de recursos: entidades y colecciones.

Las colecciones actuan como listas o contenedores de entidades, y en el caso puramente CRUD se suelen corresponder con tablas de base de datos. Normalmente su URI se deriva del nombre de la entidad que contienen. Por ejemplo, "http://www.server.com/rest/libro" sería una buena URI para la colección de todos los libros dentro de un sistema. Para cada colección se suele usar el siguiente mapeo de métodos HTTP a operaciones:

[options="header"]
|=============================================================
|Método HTTP| Operación                                       
|    GET    | Leer todas las entidades dentro de la colección
|    PUT    | Actualización mútiple y/o masiva                
|   DELETE  | Borrar la colección y todas sus entidades       
|    POST   | Crear una nueva entidad dentro de la colección  
|=============================================================

Las entidades son ocurrencias o instancias concretas, que viven dentro de una colección. La URI de una entidad se suele modelar concatenado a la URI de la colección correspondiente un identificador de entidad. Este identificador sólo necesita ser único dentro de dicha colección. Ej. "http://www.server.com/rest/libro/ASV2-4fw-3" sería el libro cuyo identificador es "ASV2-4fw-3". Normalmente se suele usar la siguiente convención a la hora de mapear métodos HTTP a operaciones cuando se trabaja con entidades.

[options="header"]
|=====================================================================
|Método HTTP| Operación                                               
|    GET    | Leer los datos de una entidad en concreto               
|    PUT    | Actualizar una entidad existente o crearla si no existe 
|   DELETE  | Borrar una entidad en concreto                          
|    POST   | Añadir información a una entidad ya existente           
|=====================================================================

A continuación, en las siguientes secciones, veremos más en detalle opciones de diseño de cada operación CRUD.

(*) El acrónimo CRUD responde a "Create Read Update Delete" y se usa para referirse a operaciones e mantenimiento de datos, normalmente sobre tablas de un gestor relacional de base de datos.

Lectura de entidades
~~~~~~~~~~~~~~~~~~~~

La operación que parece más sencilla de modelar es la de lectura, aunque como veremos el demonio está en los detalles.

Todas las operaciones de lectura y consulta deben hacerse con el método GET, ya que según la especificación indica la operación de recuperar información del servidor.

El caso más sencillo es el de leer la información de una entidad, que se realiza haciendo un GET contra la URI de la entidad. Esto no tiene mucho más misterio, salvo en el caso de que el volumen de datos de la entidad sea muy alto. En estos casos es común que queramos recuperar los datos de la entidad pero sólo para consultar una parte de la información y no toda, con lo que estamos descargando mucha información que no nos es útil.

Una posible solución es dejar sólo en esa entidad los datos de uso más común, y el resto dividirlo en varios recursos hijos. De esta manera cuando el cliente lea la entidad, sólo recibirá los datos de uso más común y un conjunto de enlaces a los recursos hijos, que contienen los diferentes detalles asociados a ésta. Cada recurso puede ser o una entidad o una colección.

En general se suele seguir la convención de concatenar el nombre del detalle a la URI de la entidad padre para conseguir la URI de la entidad hija. Por ejemplo, dada una entidad http://www.server.com/rest/libro/23424-dsdff, si se le realiza un GET, recibiríamos un documento, con el título, los autores, un resumen, valoración global, una lista de enlaces a los distintos capítulos, otra para los comentarios y valoraciones, etc. Por ejemplo, para acceder al capítulo 3, podríamos modelar los capítulos como una colección y tener la siguiente URL: http://www.server.com/rest/libro/23424-dsdff/capitulo/3. Otra opción sería no tener esa colección intermedia y hacer que cada capítulo fuera un recurso que colgara directamente del libro, con lo que la URI sería: http://www.server.com/rest/libro/23424-dsdff/capitulo3. En el primer enfoque, tenemos a nuestra disposición una colección en http://www.server.com/rest/libro/23424-dsdff/capitulo, con la cual podemos operar de forma estándar, para insertar, actualizar, borrar o consultar capítulos. Sin embargo, si decidimos no tener esta colección intermedia, la creación de nuevos capítulos y su consulta debería hacerse mediante la entidad padre. La decisión depende sobre todo del uso que vayamos a dar a los recursos hijos. Si no lo tenemos claro, o si queremos mayor flexibilidad, es mejor optar por poner una colección intermedia. Si sólo vamos a acceder a los capítulos por nombre o número, quizás sea más sencillo eliminar esa colección intermedia.

Volviendo al problema de tener una entidad con un gran volumen de datos, existe otra solución en la que no es necesario descomponerla en varios recursos. Se trata simplemente de hacer un GET a la URI de la entidad pero añadiendo una querystring. Por ejemplo, si queremos ir al capítulo número 3, podemos hacer GET sobre http://www.server.com/rest/libro/23424-dsdff?capitulo=3. De esta forma hacemos una lectura parcial de la entidad, donde el servidor devuelve la entidad libro, pero con sólo el campo relativo al capítulo 3. A esta técnica la llamo "slicing". El usar "slicing" nos lleva a olvidarnos de esta separación tan fuerte entre entidad y colección, ya que un recurso sobre el que podemos hacer "slicing" es, en cierta medida, una entidad y una colección al mismo tiempo.

Como se aprecia REST es bastante flexible y nos ofrece diferentes alternativas de diseño, el usar una u otra depende sólo de lo que pensemos que será más interoperable en cada caso. Un criterio sencillo para decidir si hacer "slicing" o descomponer la entidad en recursos de detalle, es cuantos niveles de anidamiento vamos a tener. En el caso del libro, ¿se accederá a cada capítulo como un todo o por el contrario el cliente va a necesitar acceder a las secciones de cada capítulo de forma individual? En el primer caso el "slicing" parece un buen diseño, en el segundo no lo parece tanto. Si hacemos "slicing", para acceder a la sección 4 del capítulo 3, tendríamos que hacer: http://www.server.com/rest/libro/23424-dsdff?capitulo=3&seccion=4. Este esquema de URI es menos semántico, y además nos crea el problema de que puede confundir al cliente y pensar que puede hacer cosas como esta: http://www.server.com/rest/libro/23424-dsdff?seccion=4 ¿Qué devolvemos? ¿Una lista con todas las secciones 4 de todos los capítulos? ¿Un 404 no encontrado? Sin embargo en el diseño orientado a subrecursos es claro, un GET sobre http://www.server.com/rest/libro/23424-dsdff/capitulo/3/seccion/4 nos devuelve la sección 4 del capítulo 3, y sobre http://www.server.com/rest/libro/23424-dsdff/seccion/4 nos debería devolver 404 no encontrado, ya que un libro no tiene secciones por dentro, sino capítulos. Otra desventaja del "slicing" es que la URI no es limpia, y el posicionamiento en buscadores de nuestro recurso puede ser afectado negativamente por esto (sí, un recurso REST puede tener SEO, ya lo veremos más adelante).

A veces no tenemos claro cual va a ser el uso de nuestra API REST. En estos casos es mejor optar por el modelo más flexible de URIs, de forma que podamos evolucionar el sistema sin tener que romper el esquema de URIs, cosa que rompería a todos los clientes. En este caso el sistema más flexible es descomponer la entidad en recursos de detalle, usando colecciones intermedias si es necesario.

Recordad que se tome la decisión que se tome, esta no debe afectar al diseño interno del sistema. Por ejemplo, si decidimos no descomponer la entidad en recursos hijos, eso no significa que no pueda internamente descomponer una supuesta tabla de libros, en varias tablas siguiendo un esquema maestro detalle. Y viceversa, si decido descomper la entidad en varios subrecursos, podría decidir desnormalizar y tenerlo todo en una tabla, o quizás no usar tablas sino una base de datos documental. Estas decisiones de implementación interna, guiadas por el rendimiento y la mantenibilidad del sistema, deben ser invisibles al consumidor del servicio REST.

Consultas
~~~~~~~~~

La operación más común sobre una colección es la consulta. Si queremos obtener todos los miembros de una colección, simplemente hay que realizar un GET sobre la URI de la colección. En el ejemplo de los libros sería: http://www.server.com/rest/libro. Yo he puesto "libro" en singular, pero realmente es una colección. ¿Qué nos devolvería esta llamada? Realmente hay dos opciones: una lista con enlaces a todos los libros o una lista de libros, con todos sus datos.

La petición podría ser algo así:
---------------------------
GET /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------

Una respuesta, donde se devuelvan sólo enlaces:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

["http://www.server.com/rest/libro/45",
 "http://www.server.com/rest/libro/465",
 "http://www.server.com/rest/libro/4342"]
---------------------------

Un ejemplo del segundo sería:

---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

[ {
    "id": "http://www.server.com/rest/libro/45",
    "author": "Rober Jones",
    "title": "Living in Spain",
    "genre": "biographic",
    "price": { currency:"$", amount:33.2}
  },
  {
    "id": "http://www.server.com/rest/libro/465",
    "author": "Enrique Gómez",
    "title": "Desventuras de un informático en Paris",
    "genre": "scifi",
    "price": { currency:"€", amount:10}
  },
  {
    "id": "http://www.server.com/rest/libro/4342",
    "author": "Jane Doe",
    "title": "Anonymous",
    "genre": "scifi",
    "price": { currency:"$", amount:4}
  }]
---------------------------
Observen como vienen todos los datos del libro, pero además viene un campo extra "id", con la URI de cada libro.

¿Qué es mejor? En el primer diseño la respuesta ocupa menos espacio y ahorramos ancho de banda. En el segundo se usa mayor ancho de banda, pero evitamos tener que volver a llamar a las URIs cada vez que queramos traernos los datos de cada entidad, es decir ahorramos en llamadas de red y por lo tanto en latencia. En general sólo uso la primera cuando las entidades son muy grandes, pero como hemos visto en la sección anterior, podemos descomponer las entidades grandes en recursos hijos de detalle. Por lo tanto, el uso de la segunda alternativa para modelar la respuesta a una consulta es más eficiente si lo combinamos con la descomposición de entidades grandes en recursos hijos. Por esta razón, la técnica de "slicing" se usa menos frecuentemente que la otra.

Lo normal en todo caso, no es traerse todos los miembros de una colección, sino sólo los que cumplan unos criterios de búsqueda. La forma más sencilla es definir los criterios de búsqueda en la query string.

Petición para buscar libros de ciencia ficción con un precio máximo de 20euros
---------------------------
GET /rest/libro?precio_max=20eur&genero=scifi HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

[ {
    "id": "http://www.server.com/rest/libro/4342",
    "author": "Jane Doe",
    "title": "Anonymous",
    "genre": "scifi",
    "price": { currency:"€", amount:5}
  },
  {
    "id": "http://www.server.com/rest/libro/465",
    "author": "Enrique Gómez",
    "title": "Desventuras de un informático en Paris",
    "genre": "scifi",
    "price": { currency:"€", amount:10}
  }]
---------------------------

Nótese el detalle de que los resultados viene ordenados por precio. Normalmente el servidor debería ordenar los resultados de alguna manera en función de la consulta. Si quisiéramos que el cliente definiera en un orden diferente al que proporcionamos por defecto, deberíamos dar soporte a consultas como esta: http://www.server.com/rest/libro?precio_max=20&genero=scifi&ordenarPor=genero&ascendiente=false

¿Y si queremos buscar una entidad por identificador...? Simplemente hay que hacer un GET sobre la URI de la entidad, por lo que consultas por "clave primaria" no tienen sentido dentro de una colección REST.
Petición para un libro en particular:
---------------------------
GET /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 200 Ok
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/465",
  "author": "Enrique Gómez",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:10}
}
---------------------------

Es muy común que una consulta devuelva demasiados datos. Para evitarlo podemos usar paginación. La forma más directa es añadir parámetros de paginación a la querystring. Por ejemplo:
---------------------------
GET /rest/libro?precio_max=40eur&genero=romance&ultimo_precio=12&ultimo_id=561f3&numero_resultados=10 HTTP/1.1
Host: www.server.com
Accept: application/json

---------------------------
Nótese el parámetro "numero_resultados", que indica al servidor cuantos resultados queremos como máximo. La paginación en si la hacemos usando los parámetros "ultimo_precio" y "ultimo_id", que indican cuál es el último resultado que se ha recibido. De esta forma el servidor debe realizar la consulta de forma que excluya dicho resultado y devuelva los siguientes 10 libros a partir de ése. Estamos jugando con la ordenación de los datos para conseguir la paginación. Existe otra variante para implementar la paginación y consiste en modelar directamente las páginas de resultados como recursos REST. Más adelante se hablará sobre ello.

Tal como se han diseñado las consultas anteriormente, el servidor tiene que estar preparado para interpretar correctamente los parámetros de la querystring. La ventaja es que es muy simple. La desventaja es que el cliente tiene que entender que parámetros hay disponibles y su significado, con lo que es menos interoperable. Existe otra forma de diseñar consultas, que consiste en modelarlas directamente como recursos REST. De esta forma podemos tener consultas que son recursos hijos de la colección principal. Se puede entender este enfoque como crear consultas predefinidas, filtros o vistas sobre la colección principal. En este enfoque podríamos hacer http://www.server.com/rest/libro/novedades y http://www.server.com/rest/libro/scifi para consultar las novedades y los libros de ciencia ficción respectivamente. Sobre estas colecciones hijas podemos añadir parámetros en la querystring para restringirlas más o para hacer paginación. Alternativamente podemos tener colecciones hijas anidadas hasta el nivel que necesitemos.

Esta forma de modelar consultas nos da una API mucho más limpia, y nos permite mayor interoperabilidad. Como mayor inconveniente está que es un enfoque menos flexible, ya que se necesita pensar por adelantado que consultas va a tener el sistema. Por lo tanto suele ser un diseño muy apropiado en aplicaciones de negocio donde normalmente sabemos las consultas que vamos a tener, pero no es muy apropiado en aplicaciones donde el usuario define sus propias consultas en tiempo de uso de la aplicación.

La tendencia de diseño es mezclar ambas opciones. Por un lado modelar explícitamente la consultas que se puedan detectar como colecciones hijas. Por otro lado permitir una consulta genérica, normalmente de texto libre, mediante querystring.

Actualizando
~~~~~~~~~~~~

A la hora de actualizar los datos en el servidor podemos usar dos métodos, PUT y POST. Según HTTP, PUT tiene una semántica de UPSERT, es decir, actualizar el contenido de un recurso, y si éste no existe crear un nuevo recurso con dicha información en la URI especificada. POST por el contrario puede usarse para cualquier operación que no sea ni segura ni idempotente, normalmente para añadir un trozo de información a un recurso o bien crear un nuevo recurso.

Si queremos actualizar una entidad lo más sencillo es realizar PUT sobre la URI de la entidad, e incluir en el cuerpo de la petición HTTP los nuevos datos. Por ejemplo:
---------------------------
PUT /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Y la respuesta es muy escueta:
---------------------------
HTTP/1.1 204 No Content

---------------------------
Esto tiene como consecuencia que el nuevo estado del recurso en el servidor es exactamente el mismo que el que mandamos en el cuerpo de la petición. La respuesta puede ser 204 o 200, en función de si el servidor decide enviarnos como respuesta el nuevo estado del recurso. Generalmente sólo se usa 204 ya que se supone que los datos en el servidor han quedado exactamente igual en el servidor que en el cliente. Con la respuesta 204 se pueden incluir otras cabeceras HTTP con metainformación, tales como "ETag" o "Expires". Sin embargo en algunos casos, en los que el recurso tenga propiedades de sólo lectura que deban ser recalculadas por el servidor, puede ser interesante devolver un 200 con el nuevo estado del recurso completo, incluyendo las propiedades de solo lectura.

Es decir, la semántica de PUT es una actualización donde reemplazamos por completo los datos del servidor con los que enviamos en la petición.

También podemos usar PUT para actualizar una colección ya existente. Veamos un ejemplo:
---------------------------
PUT /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 204 No Content

---------------------------
En este caso PUT ha sobreescrito los contenidos de la colección por completo, borrando los contenidos anteriores, e insertando los nuevos. Este tipo de uso de PUT no es algo que se recomiende ya que es bastante peligroso.

En los casos en los que queramos actualizar sólo algunos miembros de la colección y no otros podríamos usar una querystring para delimitar que miembros van a ser actualizados.
---------------------------
PUT /rest/libro?genero=scifi HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
La querystring define un subconjunto de recursos sobre la colección, a los cuales se les aplicará la operación PUT. De esta forma conseguimos una manera sencilla de hacer una actualización masiva. ¡ Pero esto haría que todos los libros de ciencia ficción tuvieran los mismos datos ! Realmente esto no es muy útil en este contexto. Pero sí lo es cuando estemos haciendo actualizaciones parciales, como veremos en otra sección.

En algunos casos la actualización no se puede llevar a cabo debido a que el estado del recurso lo impide, tal vez debido a alguna regla de negocio (por ejemplo, no se pueden devolver artículos pasados 3 meses desde la compra). En estos casos lo correcto es responder con un 409.
--------------------------
HTTP/1.1 409 Conflict

--------------------------

Borrando
~~~~~~~~

Para borrar una entidad o una colección, simplemente debemos hacer DELETE contra la URI del recurso.
---------------------------
DELETE /rest/libro/465 HTTP/1.1
Host: www.server.com

---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 204 No Content

---------------------------
Normalmente basta con un 204, pero en algunos casos puede ser útil un 200 para devolver algún tipo de información adicional.

Hay que tener en cuenta que borrar una entidad, debe involucrar un borrado en cascada en todas las entidades hijas. De la misma forma, si borramos una colección se deben borrar todas las entidades que pertenezcan a ella.

Otro uso interesante es usar una querystring para hacer un borrado selectivo. Por ejemplo:
---------------------------
DELETE /rest/libro?genero=scifi HTTP/1.1
Host: www.server.com

---------------------------
Borraría todos los libros de ciencia ficción. Mediante este método podemos borrar sólo los miembros de la colección que cumplen la querystring.

Creando
~~~~~~~

Una forma de crear nuevos recursos es mediante PUT. Simplemente hacemos PUT a una URI que no existe, con los datos iniciales del recurso y el servidor creará dicho recurso en la URI especificada.
Por ejemplo, para crear un nuevo libro:
---------------------------
PUT /rest/libro/465 HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Nótese que la petición es indistinguible de una actualización. El hecho de que se produzca una actualización o se cree un nuevo recurso depende únicamente de si dicho recurso, identificado por la URL, existe ya o no en el servidor. La respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.server.com/rest/libro/465
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/465"
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Nótese que el código de respuesta no es ni 200 ni 204, sino 201, indicando que el recurso se creó con éxito. Opcionalmente, como en el caso del ejemplo, se suele devolver el contenido completo del recurso recien creado. Es importante fijarse en la cabecera "Location" que indica, en este caso de forma redundante, la URL donde se ha creado el nuevo recurso.

Otro método para crear nuevos recursos usando POST. En este caso hacemos POST no sobre la URI del nuevo recurso, sino sobre la URI del recurso padre.
---------------------------
POST /rest/libro HTTP/1.1
Host: www.server.com
Accept: application/json
Content-Type: application/json

{
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
Y la respuesta:
---------------------------
HTTP/1.1 201 Created
Location: http://www.server.com/rest/libro/3d7ef
Content-Type: application/json;charset=utf-8

{
  "id": "http://www.server.com/rest/libro/3d7ef"
  "author": "Enrique Gómez Salas",
  "title": "Desventuras de un informático en Paris",
  "genre": "scifi",
  "price": { currency:"€", amount:50}
}
---------------------------
En este caso la cabecera "Location" no es superflua, ya que es el servidor quien decide la URL del nuevo recurso, no el cliente como en el caso de PUT. Además cuando creamos un nuevo recurso con POST, éste siempre queda subordinado al recurso padre. Esto no tendría porque ser así con PUT.

¿Qué es mejor? POST tiene como ventaja que la lógica de creación URIs no está en el cliente, sino bajo el control del servidor. Esto hace a nuestros servicios REST más interoperables, ya que el servidor y el cliente no se tienen que poner de acuerdo en que URIs son válidas y cuáles no, y en el algoritmo de generación de URIs. Por otro lado POST no es idempotente, mientra que PUT sí. Esto hace que PUT sea muy útil para poder recuperarnos de problemas de conectividad. Si el cliente tiene dudas sobre si su petición de creación se realizó o no, sólo tiene que repetirla. Sin embargo esto no es posible con POST, ya que duplicaríamos el recurso en el caso de que el servidor sí atendió a nuestra petición y nosotros no lo supiéramos.

Seguramente CRUD no sea lo mejor para tu API...
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hasta el momento he estado diseñando la API REST de una forma muy similar a como se diseñaría una BBDD. Algunos estarían tentados de ver las colecciones como "tablas" y las entidades como "filas", y pasar por alto el verdadero significado de lo que es un recurso REST. Este diseño ciertamente puede ser útil en casos sencillos, pero si queremos exprimir al máximo las capacidades de interoperabilidad del enfoque REST debemos ir más allá de esta forma de pensar. Más adelante veremos otras técnicas de diseño que maximizan la interoperabilidad.

Por otra parte, como se ha visto antes, no es bueno acoplar nuestro diseño de API REST a la implementación del sistema. En este sentido hay que tener cuidado con los frameworks. Por ejemplo, no es deseable el diseño de tu sistema REST se acople a tu diseño de tablas. En general el diseño de la API REST debe estar totalmente desacoplado de la implementación, y dejar que esta última pueda cambiar sin necesidad de alterar tu capa de servicios REST.

Sin embargo, en algunos escenarios sencillos, el enfoque CRUD es perfectamente válido. Por ejemplo, si simplemente queremos dotar de un API REST a una base de datos, o a nuestra capa de acceso a datos, el enfoque CRUD es perfectamente adecuado. En cualquier caso, incluso en estos escenarios, la API REST no debería exponer detalles de implementación, tales como el esquema de base de datos subyacente o las claves primarias. De este modo, si por ejemplo, decidimos desnormalizar nuestro esquema, nuestra API REST no debería tener que ser cambiada forzosamente (otra cosa es cambiar la implementación de esta).

Pero en el caso general, cuando definimos una API REST, lo que queremos exponer no es nuestra capa de acceso a datos, sino nuestra capa de lógica de aplicación. Esto implica investigar que casos de uso tenemos, cómo cambia el estado de nuestro sistema en función de las operaciones de negocio, y que información es realmente pública y cual no. Para diseñar nuestra API de forma óptima debemos ir más allá del paradigma CRUD, y empezar a pensar en casos de uso. Más adelante, en otro capítulo de este mismo libro, se explicará un enfoque mejor para este tipo de APIs: el enfoque de hypermedia o HATEOAS.

Pero antes necesitamos conocer un poco más las posibilidades que nos brinda HTTP y REST. En el siguiente capítulo veremos algunas técnicas más avanzadas que pueden ser usadas tanto en APIs orientadas a datos como en APIs basadas en hypermedia.

Referencias y bibliografía
--------------------------

[1] El acrónimo REST responde a "REpresentational State Transfer". El estilo arquitectónico REST fue descrito por primera vez por Roy Thomas Fielding, allá por el año 2000 (sí, ha llovido mucho desde entonces), si quieres leer el articulo original está públicamente accesible aquí: http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

[2] Hyper Text Transfer Protocol 1.1: http://tools.ietf.org/html/rfc2616

[3] Basic Profile Version 1.0: http://www.ws-i.org/profiles/BasicProfile-1.0-2004-04-16.html

[4] La pila ISO de protocolos de red: http://www.itu.int/rec/dologin_pub.asp?lang=e&id=T-REC-X.200-199407-I!!PDF-E&type=items y también http://en.wikipedia.org/wiki/OSI_model

[5] Uniform Resource Identifier: http://www.ietf.org/rfc/rfc3986.txt

[6] Directorio de tipos MIME estandarizados por IANA: http://www.iana.org/assignments/media-types/index.html